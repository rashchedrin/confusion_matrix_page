<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Confusion Matrix Viewer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .language-selector label {
            font-size: 20px;
            margin: 0;
        }

        .language-selector select {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .language-selector select:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .language-selector select:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        #table-input {
            width: 100%;
            height: 150px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        #table-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-container {
            margin-top: 15px;
            text-align: center;
        }

        #parse-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        #parse-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.3);
        }

        #parse-button:active {
            transform: translateY(0);
        }

        .matrix-section {
            margin-top: 30px;
        }

        .matrix-section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        .confusion-matrix {
            margin: 0 auto;
            border-collapse: collapse;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        .confusion-matrix th {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #495057;
            padding: 12px 15px;
            font-weight: 600;
            text-align: center;
            border: 1px solid #dee2e6;
            font-size: 14px;
        }

        .confusion-matrix th.corner {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
        }

        .confusion-matrix th.row-header {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            text-align: right;
            font-weight: 600;
        }

        .confusion-matrix td {
            padding: 12px 15px;
            text-align: center;
            border: 1px solid #dee2e6;
            font-weight: 500;
            font-size: 13px;
            color: #333;
            min-width: 80px;
        }

        .normalization-section {
            margin-top: 25px;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .normalization-section h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .normalization-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 10px 15px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 25px;
            transition: all 0.3s ease;
            min-width: 200px;
        }

        .radio-option:hover {
            border-color: #667eea;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.1);
        }

        .radio-option input[type="radio"] {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .radio-option input[type="radio"]:checked + span {
            font-weight: 600;
            color: #667eea;
        }

        .radio-option:has(input[type="radio"]:checked) {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
        }

        .matrix-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border: 1px solid #dee2e6;
            align-items: flex-start;
            justify-content: flex-start;
            max-width: 100%;
            box-sizing: border-box;
            overflow: visible;
            position: relative;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            flex: 0 1 auto;
            min-width: 160px;
            max-width: 220px;
            min-height: 70px;
            position: relative;
            overflow: visible;
            justify-content: flex-start;
        }

        .control-group label {
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }

        .toggle-switch {
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: relative;
            cursor: pointer;
            width: 50px;
            height: 24px;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
            flex-shrink: 0;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .label-text {
            margin: 0;
            font-size: 14px;
            font-weight: 500;
            color: #495057;
            flex-grow: 1;
        }

        .view-mode-buttons {
            display: flex;
            gap: 5px;
            width: 100%;
            max-width: 100%;
        }

        .view-btn {
            padding: 8px 16px;
            border: 2px solid #dee2e6;
            background: white;
            color: #495057;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            flex: 1;
            text-align: center;
            min-width: 0;
        }

        .view-btn:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .view-btn.active {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }

        .download-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .download-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
        }

        .text-view-container {
            margin-bottom: 20px;
        }

        .text-view-content {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        .copy-text-btn {
            margin-top: 10px;
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }

        .copy-text-btn:hover {
            background: #5a6268;
        }

        .alpha-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
            padding: 8px 12px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            transition: all 0.3s ease;
            width: fit-content;
            position: relative;
        }

        .alpha-input-group label {
            font-size: 13px;
            font-weight: 600;
            color: #495057;
            margin: 0;
        }

        .alpha-input-group input {
            width: 60px;
            padding: 3px 6px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }

        .alpha-input-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.25);
        }

        .decomposition-container {
            margin: 20px 0;
            padding: 20px;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 1px solid #90caf9;
            border-radius: 8px;
        }

        .decomposition-title {
            color: #1565c0;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }

        .decomposition-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .scaling-section {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #90caf9;
        }

        .scaling-section h4 {
            color: #1565c0;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .scaling-values {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .scaling-item {
            background: #f8f9fa;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .scaling-item .label {
            font-weight: 600;
            color: #495057;
        }

        .scaling-item .value {
            color: #1565c0;
            margin-left: 5px;
        }

        .reconstruction-formula {
            grid-column: 1 / -1;
            background: #fff3e0;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ffb74d;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #e65100;
            font-weight: 600;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #f5c6cb;
            margin-top: 15px;
            display: none;
        }

        .stats-container {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        .stat-box {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            text-align: center;
            position: relative;
            cursor: help;
        }

        .stat-box[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: normal;
            word-wrap: break-word;
            max-width: min(300px, calc(100vw - 20px));
            width: max-content;
            z-index: 1000;
            opacity: 0.95;
            margin-bottom: 5px;
            box-sizing: border-box;
        }

        .stat-box[data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #333;
            margin-bottom: -5px;
        }

        /* Tooltips handled by JavaScript - CSS tooltips disabled */
        [data-tooltip]:hover {
            cursor: help;
        }

        .stat-box h3 {
            color: #495057;
            font-size: 0.9em;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-box .value {
            font-size: 1.2em;
            font-weight: 600;
            color: #667eea;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 5px;
            }
            
            .content {
                padding: 20px;
            }
            
            .confusion-matrix {
                font-size: 12px;
            }
            
            .confusion-matrix th,
            .confusion-matrix td {
                padding: 8px 10px;
                min-width: 60px;
            }
            
            .matrix-controls {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }
            
            .control-group {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
                min-height: auto;
                min-width: auto;
                max-width: 100%;
                width: 100%;
            }
            
            .toggle-switch {
                width: auto;
                justify-content: space-between;
            }
            
            .normalization-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .radio-option {
                min-width: auto;
                justify-content: center;
            }
            
            .decomposition-content {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .scaling-values {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="position: relative;">
            <div class="language-selector">
                <label for="language-select">🌐</label>
                <select id="language-select">
                    <option value="en">English</option>
                    <option value="ru">Русский</option>
                </select>
            </div>
            <h1>Confusion Matrix Viewer</h1>
            <p>Paste your tab-separated table data and visualize it as a color-coded confusion matrix</p>
        </div>
        
        <div class="content">
            <div class="input-section">
                <h2>Input Data</h2>
                <textarea id="table-input" placeholder=""></textarea>
                <div class="button-container">
                    <button id="parse-button">Generate Confusion Matrix</button>
                </div>
                
                <div class="normalization-section" id="normalization-section" style="display: none;">
                    <h3>Normalization Options</h3>
                    <div class="normalization-controls">
                        <label class="radio-option" data-tooltip="Original confusion matrix showing raw counts or frequencies.

Interpretation:
• Each cell [i,j] = number of instances where true class was i and predicted class was j
• Row sums = total instances per true class
• Column sums = total instances per predicted class
• Diagonal elements = correctly classified instances
• Off-diagonal elements = misclassifications

Use when: You want to see absolute numbers and class imbalances.">
                            <input type="radio" name="normalization" value="none" checked>
                            <span>Original (No normalization)</span>
                        </label>
                        <label class="radio-option" data-tooltip="Row-normalized matrix showing conditional probabilities P(Predicted | True).

Interpretation:
• Each cell [i,j] = probability of predicting class j given true class i
• Each row sums to 1.0 (probability distribution)
• Diagonal elements = per-class recall (sensitivity)
• Off-diagonal elements = per-class confusion rates
• Removes class imbalance effects

Use when: You want to analyze classifier performance per true class, compare recall across classes, or when classes have different frequencies.

Example: Cell [Cat, Dog] = 0.15 means 15% of cats were misclassified as dogs.">
                            <input type="radio" name="normalization" value="row">
                            <span>Row normalized</span>
                        </label>
                        <label class="radio-option" data-tooltip="Column-normalized matrix showing conditional probabilities P(True | Predicted).

Interpretation:
• Each cell [i,j] = probability that true class is i given prediction j
• Each column sums to 1.0 (probability distribution)
• Diagonal elements = per-class precision (positive predictive value)
• Off-diagonal elements = per-prediction confusion rates
• Shows reliability of predictions

IMPORTANT: These are true posterior probabilities P(True | Predicted) ONLY if the test samples come from the same distribution as the training/validation data used to create this confusion matrix.

Use when: You want to analyze prediction reliability under the assumption that future data matches current test distribution.

Example: Cell [Cat, Dog] = 0.20 means 20% of 'Dog' predictions were actually cats (in this dataset).">
                            <input type="radio" name="normalization" value="column">
                            <span>Column normalized</span>
                        </label>
                        <label class="radio-option" data-tooltip="Sequential normalization: first by rows, then by columns.

Interpretation:
• Step 1: Row normalization creates P(Predicted | True)
• Step 2: Column normalization creates posterior probabilities P(True | Predicted) under uniform prior
• Columns sum to 1.0 (posterior probability distributions)
• Rows do not sum to 1.0 (balanced by uniform prior assumption)
• Represents Bayesian inference assuming equal class priors

Use when: You want posterior probabilities assuming uniform class distribution, remove original class frequency bias, or analyze classifier output under balanced prior assumptions.

Bayesian interpretation: Converts classifier outputs to posterior probabilities assuming P(True class) is uniform across all classes.">
                            <input type="radio" name="normalization" value="row_then_column">
                            <span>Row then column normalized</span>
                        </label>
                        <label class="radio-option" data-tooltip="Doubly stochastic matrix via iterative Sinkhorn-Knopp algorithm.

Interpretation:
• Each row AND each column sums to 1.0 simultaneously
• Creates a balanced joint probability distribution P(True, Predicted)
• Preserves relative confusion patterns while removing all bias
• Converges to optimal transport solution
• Matrix may not be symmetric (asymmetry has meaning)

Use when: You want to analyze pure confusion patterns without any class frequency or prediction bias effects, study classifier behavior in idealized balanced scenarios.

Mathematical: Finds row scaling r and column scaling c such that diag(r) × Original × diag(c) is doubly stochastic.

Asymmetry interpretation: Reflects inherent directional confusion patterns between classes.">
                            <input type="radio" name="normalization" value="sinkhorn_knopp">
                            <span>Sinkhorn-Knopp normalized</span>
                        </label>
                        <label class="radio-option" data-tooltip="Matrix normalized by total sum, creating a joint probability distribution.

Interpretation:
• Each cell [i,j] = P(True=i AND Predicted=j)
• All cells sum to 1.0 (complete probability space)
• Diagonal elements = P(correct classification)
• Off-diagonal elements = P(specific misclassification types)
• Preserves original class frequency information

Use when: You want to analyze the overall probability distribution of classification outcomes, study the likelihood of specific confusion types, or maintain class frequency relationships.

Example: Cell [Cat, Dog] = 0.05 means 5% of all classifications are 'cats predicted as dogs'.">
                            <input type="radio" name="normalization" value="sum">
                            <span>Sum normalized</span>
                        </label>
                    </div>
                </div>
                <div id="error-message" class="error-message"></div>
            </div>
            
            <div class="matrix-section">
                <h2 id="matrix-title">Confusion Matrix</h2>
                
                <div class="matrix-controls" id="matrix-controls" style="display: none;">
                    <div class="control-group">
                        <label class="toggle-switch">
                            <input type="checkbox" id="include-sums" checked>
                            <span class="slider"></span>
                            <span class="label-text">Include row/column sums</span>
                        </label>
                    </div>
                    
                    <div class="control-group">
                        <label class="toggle-switch">
                            <input type="checkbox" id="include-info" checked>
                            <span class="slider"></span>
                            <span class="label-text">Include answer information</span>
                        </label>
                    </div>
                    
                    <div class="control-group">
                        <label class="toggle-switch" data-tooltip="Additive smoothing (Laplace smoothing) adds pseudocounts to handle zero probabilities and improve estimates:

• Essential for epistemologically correct probabilities estimation
• Prevents division by zero in probability calculations
• Provides more robust statistical estimates
• Essential for reliable mutual information computation
• Recommended for sparse confusion matrices

The α parameter controls the amount of smoothing applied.">
                            <input type="checkbox" id="use-smoothing" checked>
                            <span class="slider"></span>
                            <span class="label-text">Additive smoothing</span>
                        </label>
                        <div class="alpha-input-group" id="alpha-input-group" style="display: flex;">
                            <label for="alpha-value">α =</label>
                            <input type="number" id="alpha-value" min="0" max="10" step="0.1" value="0.5" data-tooltip="Alpha parameter (pseudocounts added to each cell):

α = 0.5 (Jeffrey's Prior - RECOMMENDED):
• Non-informative Bayesian prior for Dirichlet distribution
• Scale-invariant and transformation-invariant
• Minimal bias while handling zero counts
• Theoretically optimal for unknown distributions

α = 1.0 (Laplace's Rule of Succession):
• Uniform prior assuming all outcomes equally likely
• Classic approach, easy to interpret
• Good when no prior knowledge exists
• Adds exactly 1 pseudocount per cell

α = 0 (No smoothing):
• Uses original counts without modification
• May cause issues with zero entries

Higher α values = more smoothing = more conservative estimates">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>View Mode:</label>
                        <div class="view-mode-buttons">
                            <button id="table-view-btn" class="view-btn active">Table View</button>
                            <button id="text-view-btn" class="view-btn">Tab-separated Text</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <button id="download-csv-btn" class="download-btn">Download as CSV</button>
                    </div>
                </div>
                
                <div id="matrix-container"></div>
                <div id="text-view-container" class="text-view-container" style="display: none;"></div>
                <div id="decomposition-container" class="decomposition-container" style="display: none;"></div>
                <div id="stats-container" class="stats-container" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script src="translations.js"></script>
    <script>
        // i18n
        let LANGUAGES = {};
        let currentLanguage = 'en';

        async function loadTranslations() {
            return new Promise((resolve) => {
                // Prefer window.LANGUAGES populated by translations.js
                if (window.LANGUAGES && Object.keys(window.LANGUAGES).length > 0) {
                    LANGUAGES = window.LANGUAGES;
                    resolve();
                    return;
                }
                // Fallback: check inline <script id="translations-json"> with JSON content
                const inline = document.getElementById('translations-json');
                if (inline && inline.textContent) {
                    try {
                        window.LANGUAGES = JSON.parse(inline.textContent);
                        LANGUAGES = window.LANGUAGES;
                    } catch (e) {
                        console.error('Failed to parse inline translations:', e);
                        window.LANGUAGES = {};
                        LANGUAGES = {};
                    }
                }
                resolve();
            });
        }

        function t(key) {
            const parts = key.split('.');
            let obj = LANGUAGES?.[currentLanguage]?.strings;
            if (!obj) {
                console.error(`i18n: language '${currentLanguage}' not loaded`);
                return '';
            }
            for (const part of parts) {
                if (obj && Object.prototype.hasOwnProperty.call(obj, part)) {
                    obj = obj[part];
                } else {
                    console.error(`i18n: missing key '${key}' for language '${currentLanguage}'`);
                    return '';
                }
            }
            if (typeof obj !== 'string') {
                console.error(`i18n: value for key '${key}' is not a string in language '${currentLanguage}'`);
                return '';
            }
            return obj;
        }

        function updateUILanguage() {
            const headerTitle = document.querySelector('.header h1');
            if (headerTitle) headerTitle.textContent = t('pageTitle');
            const headerSub = document.querySelector('.header p');
            if (headerSub) headerSub.textContent = t('pageSubtitle');

            const inputTitle = document.querySelector('.input-section h2');
            if (inputTitle) inputTitle.textContent = t('inputDataTitle');
            const textarea = document.getElementById('table-input');
            if (textarea) {
                textarea.placeholder = t('inputPlaceholder');

                // Update example data in textarea if it contains default example
                const currentValue = textarea.value.trim();
                const englishExample = LANGUAGES?.en?.strings?.exampleData || '';
                const russianExample = LANGUAGES?.ru?.strings?.exampleData || '';

                // If current value is a default example (in any language), update it
                if (currentValue === englishExample || currentValue === russianExample) {
                    textarea.value = t('exampleData');
                    // Re-process the input to update the matrix display
                    if (typeof processTableInput === 'function') {
                        processTableInput();
                    }
                }
            }
            const genBtn = document.getElementById('parse-button');
            if (genBtn) genBtn.textContent = t('generateButton');

            const normTitle = document.querySelector('.normalization-section h3');
            if (normTitle) normTitle.textContent = t('normalizationTitle');
            const radioOptions = document.querySelectorAll('.normalization-controls .radio-option');
            if (radioOptions.length >= 6) {
                radioOptions[0].querySelector('span').textContent = t('normOriginal');
                radioOptions[1].querySelector('span').textContent = t('normRow');
                radioOptions[2].querySelector('span').textContent = t('normColumn');
                radioOptions[3].querySelector('span').textContent = t('normRowColumn');
                radioOptions[4].querySelector('span').textContent = t('normSinkhorn');
                radioOptions[5].querySelector('span').textContent = t('normSum');

                // tooltips
                radioOptions[0].setAttribute('data-tooltip', t('tooltips.original'));
                radioOptions[1].setAttribute('data-tooltip', t('tooltips.rowNorm'));
                radioOptions[2].setAttribute('data-tooltip', t('tooltips.columnNorm'));
                radioOptions[3].setAttribute('data-tooltip', t('tooltips.rowColumnNorm'));
                radioOptions[4].setAttribute('data-tooltip', t('tooltips.sinkhornNorm'));
                radioOptions[5].setAttribute('data-tooltip', t('tooltips.sumNorm'));
            }

            // Controls
            const labelTexts = document.querySelectorAll('.label-text');
            if (labelTexts.length >= 3) {
                labelTexts[0].textContent = t('includeRowColumnSums');
                labelTexts[1].textContent = t('includeAnswerInfo');
                labelTexts[1].parentElement?.setAttribute?.('data-tooltip', t('tooltips.answerInfo'));
                labelTexts[2].textContent = t('additiveSmoothing');
            }
            const smoothingToggle = document.querySelector('.toggle-switch[data-tooltip]');
            if (smoothingToggle) smoothingToggle.setAttribute('data-tooltip', t('tooltips.smoothingToggle'));
            const alphaInput = document.getElementById('alpha-value');
            if (alphaInput) alphaInput.setAttribute('data-tooltip', t('tooltips.alphaParam'));

            // View mode
            const viewModeLabels = document.querySelectorAll('.control-group label');
            for (let label of viewModeLabels) {
                if (label.textContent && label.textContent.includes('View Mode')) {
                    label.textContent = t('viewMode');
                    break;
                }
            }
            const viewButtons = document.querySelectorAll('.view-btn');
            if (viewButtons.length >= 2) {
                viewButtons[0].textContent = t('tableView');
                viewButtons[1].textContent = t('tabSeparatedText');
            }
            const downloadBtn = document.getElementById('download-csv-btn');
            if (downloadBtn) downloadBtn.textContent = t('downloadCSV');

            initializeTooltips();
        }
        /**
         * Tests the table parser with various input formats
         * @returns {boolean} True if all tests pass
         */
        function runParserTests() {
            const tests = [
                {
                    name: "Tab-separated with Russian labels",
                    input: `Жираф\tНосорог\tКраб\n1\t0\t0\n0\t1\t0\n0\t0\t1`,
                    expected: { rows: 3, cols: 3 }
                },
                {
                    name: "Space-separated with Russian labels",
                    input: `Жираф Носорог Краб\n1 0 0\n0 1 0\n0 0 1`,
                    expected: { rows: 3, cols: 3 }
                },
                {
                    name: "User's failing case (header tabs, data spaces)",
                    input: `Жираф\tНосорог\tКраб\t\n1    0    0\n0    1    0  \n0    0    1`,
                    expected: { rows: 3, cols: 3 }
                },
                {
                    name: "Mixed separators per line (tabs and spaces)",
                    input: `A\tB\tC\n1 2 3\n4\t5\t6`,
                    expected: { rows: 2, cols: 3 }
                },
                {
                    name: "Pure space-separated (no tabs)",
                    input: `Жираф Носорог Краб \n1 0 0\n0 1 0  \n0 0 1`,
                    expected: { rows: 3, cols: 3 }
                },
                {
                    name: "Multiple spaces",
                    input: `Class1    Class2    Class3\n0.85      0.10      0.05\n0.15      0.80      0.05`,
                    expected: { rows: 2, cols: 3 }
                },
                {
                    name: "Tab with trailing whitespace",
                    input: `Жираф\tНосорог\tКраб\t\n1\t0\t0\n0\t1\t0\n0\t0\t1`,
                    expected: { rows: 3, cols: 3 }
                },
                {
                    name: "Mixed tab and space (should use tab)",
                    input: `A\tB C\tD\n1\t2 3\t4\n5\t6 7\t8`,
                    expected: { rows: 2, cols: 3 }
                },
                {
                    name: "Comma decimals",
                    input: `A B C\n0,85 0,10 0,05\n0,15 0,80 0,05`,
                    expected: { rows: 2, cols: 3 }
                },
                {
                    name: "Empty trailing cells (tabs)",
                    input: `A\tB\tC\t\n1\t2\t3\t\n4\t5\t6\t`,
                    expected: { rows: 2, cols: 3 }
                },
                {
                    name: "Empty trailing cells (spaces)", 
                    input: `A B C \n1 2 3 \n4 5 6 `,
                    expected: { rows: 2, cols: 3 }
                }
            ];

            let passed = 0;
            let failed = 0;

            for (const test of tests) {
                try {
                    console.log(`Testing: ${test.name}`);
                    console.log(`Input: "${test.input}"`);
                    
                    const result = parseTableData(test.input);
                    const actual_rows = result.matrix_values.length;
                    const actual_cols = result.matrix_values[0].length;
                    
                    if (actual_rows === test.expected.rows && actual_cols === test.expected.cols) {
                        console.log(`✅ PASS: ${test.name}`);
                        passed++;
                    } else {
                        console.log(`❌ FAIL: ${test.name} - Expected ${test.expected.rows}x${test.expected.cols}, got ${actual_rows}x${actual_cols}`);
                        failed++;
                    }
                    console.log(`Result:`, result);
                } catch (error) {
                    console.log(`❌ ERROR: ${test.name} - ${error.message}`);
                    failed++;
                }
                console.log('---');
            }

            console.log(`Tests completed: ${passed} passed, ${failed} failed`);
            return failed === 0;
        }

        /**
         * Parses table data with tab or space separators into a structured format
         * @param {string} table_data - Raw table data (tab or space separated)
         * @returns {Object} Parsed data with headers and matrix values
         */
        function parseTableData(table_data) {
            const lines = table_data.trim().split('\n').filter(line => line.trim());
            
            if (lines.length < 2) {
                throw new Error('Table must have at least a header row and one data row');
            }
            
            // Smart separator detection: check each line individually
            function detectSeparator(line) {
                if (line.includes('\t')) {
                    return '\t';
                } else {
                    return /\s+/;
                }
            }
            
            function splitLine(line) {
                const separator = detectSeparator(line);
                return line.split(separator).map(cell => cell.trim()).filter(cell => cell.length > 0);
            }
            
            // Parse header row
            const header_row = splitLine(lines[0]);
            const column_labels = header_row;
            
            // Parse data rows
            const data_rows = [];
            const row_labels = [];
            
            for (let row_index = 1; row_index < lines.length; row_index++) {
                const cells = splitLine(lines[row_index]);
                
                if (cells.length !== header_row.length) {
                    throw new Error(`Row ${row_index + 1} has ${cells.length} columns, expected ${header_row.length}`);
                }
                
                const numeric_values = [];
                for (let col_index = 0; col_index < cells.length; col_index++) {
                    // Handle comma decimal separator
                    const normalized_value = cells[col_index].replace(',', '.');
                    const parsed_value = parseFloat(normalized_value);
                    
                    if (isNaN(parsed_value)) {
                        throw new Error(`Invalid numeric value "${cells[col_index]}" at row ${row_index + 1}, column ${col_index + 1}`);
                    }
                    
                    numeric_values.push(parsed_value);
                }
                
                data_rows.push(numeric_values);
                row_labels.push(column_labels[row_index - 1] || `Row ${row_index}`);
            }
            
            return {
                column_labels: column_labels,
                row_labels: row_labels,
                matrix_values: data_rows
            };
        }

        /**
         * Generates RGB color value for white-to-blue colormap
         * @param {number} normalized_value - Value between 0 and 1
         * @returns {string} RGB color string
         */
        function generateColorFromValue(normalized_value) {
            // Ensure value is between 0 and 1
            const clamped_value = Math.max(0, Math.min(1, normalized_value));
            
            // White to blue transition
            const red_component = Math.round(255 * (1 - clamped_value));
            const green_component = Math.round(255 * (1 - clamped_value));
            const blue_component = 255;
            
            return `rgb(${red_component}, ${green_component}, ${blue_component})`;
        }

        /**
         * Normalizes matrix rows so each row sums to 1
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<Array<number>>} Row-normalized matrix
         */
        function normalizeByRows(matrix_values) {
            return matrix_values.map(row => {
                const row_sum = row.reduce((sum, value) => sum + value, 0);
                if (row_sum === 0) {
                    return row.map(() => 0);
                }
                return row.map(value => value / row_sum);
            });
        }

        /**
         * Normalizes matrix columns so each column sums to 1
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<Array<number>>} Column-normalized matrix
         */
        function normalizeByColumns(matrix_values) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            // Calculate column sums
            const column_sums = new Array(num_cols).fill(0);
            for (let row_index = 0; row_index < num_rows; row_index++) {
                for (let col_index = 0; col_index < num_cols; col_index++) {
                    column_sums[col_index] += matrix_values[row_index][col_index];
                }
            }
            
            // Normalize each element by its column sum
            const normalized_matrix = [];
            for (let row_index = 0; row_index < num_rows; row_index++) {
                const normalized_row = [];
                for (let col_index = 0; col_index < num_cols; col_index++) {
                    if (column_sums[col_index] === 0) {
                        normalized_row.push(0);
                    } else {
                        normalized_row.push(matrix_values[row_index][col_index] / column_sums[col_index]);
                    }
                }
                normalized_matrix.push(normalized_row);
            }
            
            return normalized_matrix;
        }

        /**
         * Normalizes matrix by rows first, then by columns
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<Array<number>>} Row-then-column normalized matrix
         */
        function normalizeRowThenColumn(matrix_values) {
            const row_normalized = normalizeByRows(matrix_values);
            return normalizeByColumns(row_normalized);
        }

        /**
         * Applies Sinkhorn-Knopp normalization algorithm with RAS decomposition
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @param {number} max_iterations - Maximum number of iterations (default: 100)
         * @param {number} tolerance - Convergence tolerance (default: 1e-6)
         * @param {boolean} return_decomposition - Whether to return decomposition info
         * @returns {Array<Array<number>>|Object} Sinkhorn-Knopp normalized matrix or decomposition object
         */
        function normalizeSinkhornKnopp(matrix_values, max_iterations = 100, tolerance = 1e-6, return_decomposition = false) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            // Create a copy of the matrix
            let current_matrix = matrix_values.map(row => [...row]);
            
            // Check if matrix has any non-zero elements
            const total_sum = current_matrix.flat().reduce((sum, val) => sum + val, 0);
            if (total_sum === 0) {
                if (return_decomposition) {
                    return {
                        matrix: current_matrix,
                        row_scaling: new Array(num_rows).fill(1),
                        column_scaling: new Array(num_cols).fill(1),
                        doubly_stochastic: current_matrix.map(row => [...row])
                    };
                }
                return current_matrix;
            }
            
            // Initialize scaling factors for RAS decomposition
            let row_scaling = new Array(num_rows).fill(1);
            let column_scaling = new Array(num_cols).fill(1);
            
            for (let iteration = 0; iteration < max_iterations; iteration++) {
                // Store previous matrix for convergence check
                const previous_matrix = current_matrix.map(row => [...row]);
                
                // Row scaling step
                for (let row_index = 0; row_index < num_rows; row_index++) {
                    const row_sum = current_matrix[row_index].reduce((sum, val) => sum + val, 0);
                    if (row_sum > 0) {
                        const row_factor = 1 / row_sum;
                        row_scaling[row_index] *= row_factor;
                        for (let col_index = 0; col_index < num_cols; col_index++) {
                            current_matrix[row_index][col_index] *= row_factor;
                        }
                    }
                }
                
                // Column scaling step
                for (let col_index = 0; col_index < num_cols; col_index++) {
                    let col_sum = 0;
                    for (let row_index = 0; row_index < num_rows; row_index++) {
                        col_sum += current_matrix[row_index][col_index];
                    }
                    if (col_sum > 0) {
                        const col_factor = 1 / col_sum;
                        column_scaling[col_index] *= col_factor;
                        for (let row_index = 0; row_index < num_rows; row_index++) {
                            current_matrix[row_index][col_index] *= col_factor;
                        }
                    }
                }
                
                // Check for convergence
                let max_difference = 0;
                for (let row_index = 0; row_index < num_rows; row_index++) {
                    for (let col_index = 0; col_index < num_cols; col_index++) {
                        const difference = Math.abs(current_matrix[row_index][col_index] - previous_matrix[row_index][col_index]);
                        max_difference = Math.max(max_difference, difference);
                    }
                }
                
                if (max_difference < tolerance) {
                    break;
                }
            }
            
            if (return_decomposition) {
                return {
                    matrix: current_matrix,
                    row_scaling: row_scaling,
                    column_scaling: column_scaling,
                    doubly_stochastic: current_matrix.map(row => [...row])
                };
            }
            
            return current_matrix;
        }

        /**
         * Applies additive smoothing (Laplace smoothing) to matrix values
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @param {number} alpha - Smoothing parameter (pseudocount)
         * @returns {Array<Array<number>>} Smoothed matrix with alpha added to each cell
         */
        function applyAdditiveSmoothing(matrix_values, alpha = 0.5) {
            return matrix_values.map(row => 
                row.map(val => val + alpha)
            );
        }

        /**
         * Normalizes matrix by dividing all elements by the total sum
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<Array<number>>} Sum-normalized matrix (joint probability distribution)
         */
        function normalizeBySum(matrix_values) {
            const total_sum = matrix_values.flat().reduce((sum, val) => sum + val, 0);
            
            if (total_sum === 0) {
                return matrix_values.map(row => [...row]); // Return copy of zero matrix
            }
            
            return matrix_values.map(row => 
                row.map(val => val / total_sum)
            );
        }

        /**
         * Applies the selected normalization to matrix values with optional preprocessing
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} use_smoothing - Whether to apply additive smoothing
         * @param {number} alpha - Smoothing parameter (if smoothing enabled)
         * @returns {Array<Array<number>>} Normalized matrix
         */
        function applyNormalization(matrix_values, normalization_type, use_smoothing = false, alpha = 0.5) {
            // Apply smoothing preprocessing if enabled
            let processed_matrix = matrix_values;
            if (use_smoothing) {
                processed_matrix = applyAdditiveSmoothing(matrix_values, alpha);
            }
            
            switch (normalization_type) {
                case 'row':
                    return normalizeByRows(processed_matrix);
                case 'column':
                    return normalizeByColumns(processed_matrix);
                case 'row_then_column':
                    return normalizeRowThenColumn(processed_matrix);
                case 'sinkhorn_knopp':
                    return normalizeSinkhornKnopp(processed_matrix);
                case 'sum':
                    return normalizeBySum(processed_matrix);
                case 'none':
                default:
                    return processed_matrix;
            }
        }

        /**
         * Calculates color intensity based on matrix values
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<Array<number>>} Normalized values for color mapping
         */
        function calculateColorIntensities(matrix_values) {
            // Find min and max values across entire matrix
            let min_value = Infinity;
            let max_value = -Infinity;
            
            for (const row_values of matrix_values) {
                for (const cell_value of row_values) {
                    min_value = Math.min(min_value, cell_value);
                    max_value = Math.max(max_value, cell_value);
                }
            }
            
            // Handle edge case where all values are the same
            const value_range = max_value - min_value;
            if (value_range === 0) {
                return matrix_values.map(row => row.map(() => 0.5));
            }
            
            // Normalize values to 0-1 range
            return matrix_values.map(row => 
                row.map(value => (value - min_value) / value_range)
            );
        }

        /**
         * Renders the confusion matrix as an HTML table
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} include_sums - Whether to include row/column sums
         * @param {boolean} include_info - Whether to include answer information row
         * side-effects: Modifies DOM element with id 'matrix-container'
         */
        function renderConfusionMatrix(parsed_data, normalization_type = 'none', include_sums = true, include_info = true, use_smoothing = false, alpha = 0.5) {
            const matrix_container = document.getElementById('matrix-container');
            const normalized_matrix = applyNormalization(parsed_data.matrix_values, normalization_type, use_smoothing, alpha);
            const normalized_intensities = calculateColorIntensities(normalized_matrix);
            
            // Calculate row sums, column sums, and total sum
            const row_sums = normalized_matrix.map(row => row.reduce((sum, val) => sum + val, 0));
            const column_sums = [];
            for (let col_index = 0; col_index < normalized_matrix[0].length; col_index++) {
                let col_sum = 0;
                for (let row_index = 0; row_index < normalized_matrix.length; row_index++) {
                    col_sum += normalized_matrix[row_index][col_index];
                }
                column_sums.push(col_sum);
            }
            const total_sum = row_sums.reduce((sum, val) => sum + val, 0);
            
            // Calculate answer information if needed
            let answer_information = [];
            if (include_info) {
                answer_information = calculateClassifierAnswerInformation(normalized_matrix);
            }
            
            // Create table element
            const table_element = document.createElement('table');
            table_element.className = 'confusion-matrix';
            
            // Create header row
            const header_row = document.createElement('tr');
            
            // Corner cell
            const corner_cell = document.createElement('th');
            corner_cell.className = 'corner';
            try {
                corner_cell.textContent = `${t('predictedLabel')}\n${t('actualLabel')}`;
            } catch (_) {
                corner_cell.textContent = 'Predicted →\nActual ↓';
            }
            corner_cell.style.whiteSpace = 'pre-line';
            header_row.appendChild(corner_cell);
            
            // Column headers
            for (const column_label of parsed_data.column_labels) {
                const header_cell = document.createElement('th');
                header_cell.textContent = column_label;
                header_row.appendChild(header_cell);
            }
            
            // Sum column header
            if (include_sums) {
                const sum_header_cell = document.createElement('th');
                sum_header_cell.textContent = t('sumLabel');
                sum_header_cell.style.backgroundColor = '#e9ecef';
                sum_header_cell.style.fontWeight = 'bold';
                header_row.appendChild(sum_header_cell);
            }
            
            table_element.appendChild(header_row);
            
            // Create data rows
            for (let row_index = 0; row_index < parsed_data.matrix_values.length; row_index++) {
                const data_row = document.createElement('tr');
                
                // Row header
                const row_header_cell = document.createElement('th');
                row_header_cell.className = 'row-header';
                row_header_cell.textContent = parsed_data.row_labels[row_index];
                data_row.appendChild(row_header_cell);
                
                // Data cells
                for (let col_index = 0; col_index < normalized_matrix[row_index].length; col_index++) {
                    const data_cell = document.createElement('td');
                    const cell_value = normalized_matrix[row_index][col_index];
                    const color_intensity = normalized_intensities[row_index][col_index];
                    
                    data_cell.textContent = cell_value.toFixed(4);
                    data_cell.style.backgroundColor = generateColorFromValue(color_intensity);
                    
                    // Add white text for dark cells
                    if (color_intensity > 0.6) {
                        data_cell.style.color = 'white';
                    }
                    
                    data_row.appendChild(data_cell);
                }
                
                // Row sum cell
                if (include_sums) {
                    const row_sum_cell = document.createElement('td');
                    row_sum_cell.textContent = row_sums[row_index].toFixed(4);
                    row_sum_cell.style.backgroundColor = '#f8f9fa';
                    row_sum_cell.style.fontWeight = 'bold';
                    row_sum_cell.style.borderLeft = '2px solid #dee2e6';
                    data_row.appendChild(row_sum_cell);
                }
                
                table_element.appendChild(data_row);
            }
            
            // Add column sum row
            if (include_sums) {
                const sum_row = document.createElement('tr');
                
                // Sum row header
                const sum_row_header = document.createElement('th');
                sum_row_header.className = 'row-header';
                sum_row_header.textContent = t('sumLabel');
                sum_row_header.style.backgroundColor = '#e9ecef';
                sum_row_header.style.fontWeight = 'bold';
                sum_row_header.style.borderTop = '2px solid #dee2e6';
                sum_row.appendChild(sum_row_header);
                
                // Column sum cells
                for (let col_index = 0; col_index < column_sums.length; col_index++) {
                    const col_sum_cell = document.createElement('td');
                    col_sum_cell.textContent = column_sums[col_index].toFixed(4);
                    col_sum_cell.style.backgroundColor = '#f8f9fa';
                    col_sum_cell.style.fontWeight = 'bold';
                    col_sum_cell.style.borderTop = '2px solid #dee2e6';
                    sum_row.appendChild(col_sum_cell);
                }
                
                // Total sum cell (intersection of Sum row and Sum column)
                const total_sum_cell = document.createElement('td');
                total_sum_cell.textContent = total_sum.toFixed(4);
                total_sum_cell.style.backgroundColor = '#e9ecef';
                total_sum_cell.style.fontWeight = 'bold';
                total_sum_cell.style.borderTop = '2px solid #dee2e6';
                total_sum_cell.style.borderLeft = '2px solid #dee2e6';
                sum_row.appendChild(total_sum_cell);
                
                table_element.appendChild(sum_row);
            }
            
            // Add answer information row
            if (include_info) {
                const info_row = document.createElement('tr');
                
                // Info row header
                const info_row_header = document.createElement('th');
                info_row_header.className = 'row-header';
                info_row_header.textContent = t('answerInfoLabel');
                info_row_header.setAttribute('data-tooltip', t('tooltips.answerInfo'));
                info_row_header.style.backgroundColor = '#e3f2fd';
                info_row_header.style.fontWeight = 'bold';
                info_row_header.style.borderTop = '2px solid #90caf9';
                info_row_header.style.color = '#1565c0';
                info_row.appendChild(info_row_header);

                // Attach custom tooltip handlers to match existing style
                info_row_header.addEventListener('mouseenter', function(event) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'custom-tooltip';
                    tooltip.textContent = this.getAttribute('data-tooltip');
                    Object.assign(tooltip.style, {
                        position: 'fixed',
                        background: '#333',
                        color: 'white',
                        padding: '16px 20px',
                        borderRadius: '8px',
                        fontSize: '14px',
                        lineHeight: '1.5',
                        whiteSpace: 'pre-line',
                        zIndex: '9999',
                        opacity: '0.95',
                        maxWidth: '400px',
                        textAlign: 'left',
                        boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                        pointerEvents: 'none',
                        fontFamily: 'system-ui, -apple-system, sans-serif'
                    });
                    const rect = this.getBoundingClientRect();
                    tooltip.style.left = (rect.left + rect.width / 2) + 'px';
                    tooltip.style.top = (rect.top - 10) + 'px';
                    tooltip.style.transform = 'translateX(-50%) translateY(-100%)';
                    document.body.appendChild(tooltip);
                });
                info_row_header.addEventListener('mouseleave', function() {
                    const tooltips = document.querySelectorAll('.custom-tooltip');
                    tooltips.forEach(tooltip => tooltip.remove());
                });
                
                // Answer information cells
                for (let col_index = 0; col_index < answer_information.length; col_index++) {
                    const info_cell = document.createElement('td');
                    info_cell.textContent = answer_information[col_index].toFixed(3);
                    info_cell.style.backgroundColor = '#f3e5f5';
                    info_cell.style.fontWeight = 'bold';
                    info_cell.style.borderTop = '2px solid #90caf9';
                    info_cell.style.color = '#4a148c';
                    info_row.appendChild(info_cell);
                }
                
                // Empty cell for sum column if sums are included
                if (include_sums) {
                    const empty_cell = document.createElement('td');
                    empty_cell.style.backgroundColor = '#f3e5f5';
                    empty_cell.style.borderTop = '2px solid #90caf9';
                    empty_cell.style.borderLeft = '2px solid #dee2e6';
                    info_row.appendChild(empty_cell);
                }
                
                table_element.appendChild(info_row);
            }
            
            matrix_container.innerHTML = '';
            matrix_container.appendChild(table_element);
        }

        /**
         * Generates tab-separated text representation of the matrix
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} include_sums - Whether to include row/column sums
         * @returns {string} Tab-separated text representation
         */
        function generateTabSeparatedText(parsed_data, normalization_type = 'none', include_sums = true) {
            const normalized_matrix = applyNormalization(parsed_data.matrix_values, normalization_type);
            
            // Get decomposition for Sinkhorn-Knopp
            let decomposition = null;
            if (normalization_type === 'sinkhorn_knopp') {
                decomposition = normalizeSinkhornKnopp(parsed_data.matrix_values, 100, 1e-6, true);
            }
            
            // Calculate sums if needed
            let row_sums = [];
            let column_sums = [];
            let total_sum = 0;
            
            if (include_sums) {
                row_sums = normalized_matrix.map(row => row.reduce((sum, val) => sum + val, 0));
                column_sums = [];
                for (let col_index = 0; col_index < normalized_matrix[0].length; col_index++) {
                    let col_sum = 0;
                    for (let row_index = 0; row_index < normalized_matrix.length; row_index++) {
                        col_sum += normalized_matrix[row_index][col_index];
                    }
                    column_sums.push(col_sum);
                }
                total_sum = row_sums.reduce((sum, val) => sum + val, 0);
            }
            
            let text_content = '';
            
            // Header row
            text_content += '\t' + parsed_data.column_labels.join('\t');
            if (include_sums) {
                text_content += '\tSum';
            }
            if (decomposition) {
                text_content += '\tRow Scaling (r)';
            }
            text_content += '\n';
            
            // Data rows
            for (let row_index = 0; row_index < normalized_matrix.length; row_index++) {
                text_content += parsed_data.row_labels[row_index] + '\t';
                text_content += normalized_matrix[row_index].map(val => val.toFixed(4)).join('\t');
                if (include_sums) {
                    text_content += '\t' + row_sums[row_index].toFixed(4);
                }
                if (decomposition) {
                    text_content += '\t' + decomposition.row_scaling[row_index].toFixed(6);
                }
                text_content += '\n';
            }
            
            // Sum row
            if (include_sums) {
                text_content += 'Sum\t';
                text_content += column_sums.map(val => val.toFixed(4)).join('\t');
                text_content += '\t' + total_sum.toFixed(4);
                if (decomposition) {
                    text_content += '\t';  // Empty cell for row scaling column
                }
                text_content += '\n';
            }
            
            // Column scaling row for Sinkhorn-Knopp
            if (decomposition) {
                text_content += 'Column Scaling (c)\t';
                text_content += decomposition.column_scaling.map(val => val.toFixed(6)).join('\t');
                if (include_sums) {
                    text_content += '\t';  // Empty cell for sum column
                }
                text_content += '\t';  // Empty cell for row scaling column
                text_content += '\n';
                
                // Add reconstruction formula
                text_content += '\n';
                text_content += '# ' + t('tooltips.rasTooltip') + '\n';
                text_content += '# ' + t('tooltips.reconstructionTooltip') + '\n';
                text_content += '# ' + t('tooltips.rowScalingFactors') + ' and ' + t('tooltips.columnScalingFactors') + ' are included above\n';
            }
            
            return text_content;
        }

        /**
         * Generates CSV representation of the matrix
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} include_sums - Whether to include row/column sums
         * @returns {string} CSV representation
         */
        function generateCSV(parsed_data, normalization_type = 'none', include_sums = true) {
            const normalized_matrix = applyNormalization(parsed_data.matrix_values, normalization_type);
            
            // Get decomposition for Sinkhorn-Knopp
            let decomposition = null;
            if (normalization_type === 'sinkhorn_knopp') {
                decomposition = normalizeSinkhornKnopp(parsed_data.matrix_values, 100, 1e-6, true);
            }
            
            // Calculate sums if needed
            let row_sums = [];
            let column_sums = [];
            let total_sum = 0;
            
            if (include_sums) {
                row_sums = normalized_matrix.map(row => row.reduce((sum, val) => sum + val, 0));
                column_sums = [];
                for (let col_index = 0; col_index < normalized_matrix[0].length; col_index++) {
                    let col_sum = 0;
                    for (let row_index = 0; row_index < normalized_matrix.length; row_index++) {
                        col_sum += normalized_matrix[row_index][col_index];
                    }
                    column_sums.push(col_sum);
                }
                total_sum = row_sums.reduce((sum, val) => sum + val, 0);
            }
            
            let csv_content = '';
            
            // Header row
            csv_content += ',' + parsed_data.column_labels.map(label => `"${label}"`).join(',');
            if (include_sums) {
                csv_content += ',"' + t('sumLabel') + '"';
            }
            if (decomposition) {
                csv_content += ',"Row Scaling (r)"';
            }
            csv_content += '\n';
            
            // Data rows
            for (let row_index = 0; row_index < normalized_matrix.length; row_index++) {
                csv_content += `"${parsed_data.row_labels[row_index]}",`;
                csv_content += normalized_matrix[row_index].map(val => val.toFixed(4)).join(',');
                if (include_sums) {
                    csv_content += ',' + row_sums[row_index].toFixed(4);
                }
                if (decomposition) {
                    csv_content += ',' + decomposition.row_scaling[row_index].toFixed(6);
                }
                csv_content += '\n';
            }
            
            // Sum row
            if (include_sums) {
                csv_content += '"' + t('sumLabel') + '",';
                csv_content += column_sums.map(val => val.toFixed(4)).join(',');
                csv_content += ',' + total_sum.toFixed(4);
                if (decomposition) {
                    csv_content += ',';  // Empty cell for row scaling column
                }
                csv_content += '\n';
            }
            
            // Column scaling row for Sinkhorn-Knopp
            if (decomposition) {
                csv_content += '"Column Scaling (c)",';
                csv_content += decomposition.column_scaling.map(val => val.toFixed(6)).join(',');
                if (include_sums) {
                    csv_content += ',';  // Empty cell for sum column
                }
                csv_content += ',';  // Empty cell for row scaling column
                csv_content += '\n';
                
                // Add reconstruction formula as comment
                csv_content += '\n';
                csv_content += '"# ' + t('tooltips.rasTooltip') + '"\n';
                csv_content += '"# ' + t('tooltips.reconstructionTooltip') + '"\n';
                csv_content += '"# ' + t('tooltips.rowScalingFactors') + ' and ' + t('tooltips.columnScalingFactors') + ' are included above"\n';
            }
            
            return csv_content;
        }

        /**
         * Renders the tab-separated text view
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} include_sums - Whether to include row/column sums
         * side-effects: Modifies DOM element with id 'text-view-container'
         */
        function renderTextView(parsed_data, normalization_type = 'none', include_sums = true) {
            const text_container = document.getElementById('text-view-container');
            const text_content = generateTabSeparatedText(parsed_data, normalization_type, include_sums);
            
            text_container.innerHTML = `
                <div class="text-view-content">${text_content}</div>
                <button class="copy-text-btn" onclick="copyTextToClipboard()">Copy to Clipboard</button>
            `;
        }

        /**
         * Downloads matrix as CSV file
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} include_sums - Whether to include row/column sums
         * side-effects: Triggers file download
         */
        function downloadAsCSV(parsed_data, normalization_type = 'none', include_sums = true) {
            const csv_content = generateCSV(parsed_data, normalization_type, include_sums);
            
            const normalization_suffix = normalization_type === 'none' ? '' : `_${normalization_type}`;
            const filename = `confusion_matrix${normalization_suffix}.csv`;
            
            const blob = new Blob([csv_content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        /**
         * Copies text view content to clipboard
         * side-effects: Copies text to clipboard, shows temporary feedback
         */
        function copyTextToClipboard() {
            const text_content = document.querySelector('.text-view-content').textContent;
            navigator.clipboard.writeText(text_content).then(() => {
                const copy_button = document.querySelector('.copy-text-btn');
                const original_text = copy_button.textContent;
                copy_button.textContent = 'Copied!';
                copy_button.style.backgroundColor = '#28a745';
                
                setTimeout(() => {
                    copy_button.textContent = original_text;
                    copy_button.style.backgroundColor = '#6c757d';
                }, 2000);
            }).catch(() => {
                alert('Failed to copy text to clipboard');
            });
        }

        /**
         * Calculates the trace of a square matrix (sum of diagonal elements)
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {number} Trace of the matrix
         */
        function calculateTrace(matrix_values) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            const min_dimension = Math.min(num_rows, num_cols);
            
            let trace_sum = 0;
            for (let index = 0; index < min_dimension; index++) {
                trace_sum += matrix_values[index][index];
            }
            
            return trace_sum;
        }

        /**
         * Calculates mutual information for confusion matrix
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values (must be probabilities/normalized)
         * @returns {number} Mutual information value
         */
        function calculateMutualInformation(matrix_values) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            // Calculate total sum to ensure matrix is normalized
            const total_sum = matrix_values.flat().reduce((sum, val) => sum + val, 0);
            
            // If matrix is not normalized, normalize it for MI calculation
            let normalized_matrix = matrix_values;
            if (Math.abs(total_sum - 1.0) > 1e-10) {
                if (total_sum === 0) {
                    return 0; // Cannot calculate MI for zero matrix
                }
                normalized_matrix = matrix_values.map(row => 
                    row.map(val => val / total_sum)
                );
            }
            
            // Calculate marginal probabilities
            const row_marginals = normalized_matrix.map(row => 
                row.reduce((sum, val) => sum + val, 0)
            );
            
            const column_marginals = [];
            for (let col_index = 0; col_index < num_cols; col_index++) {
                let col_sum = 0;
                for (let row_index = 0; row_index < num_rows; row_index++) {
                    col_sum += normalized_matrix[row_index][col_index];
                }
                column_marginals.push(col_sum);
            }
            
            // Calculate mutual information
            let mutual_information = 0;
            for (let row_index = 0; row_index < num_rows; row_index++) {
                for (let col_index = 0; col_index < num_cols; col_index++) {
                    const joint_prob = normalized_matrix[row_index][col_index];
                    const row_marginal = row_marginals[row_index];
                    const col_marginal = column_marginals[col_index];
                    
                    // Only add to MI if joint probability is non-zero
                    if (joint_prob > 0 && row_marginal > 0 && col_marginal > 0) {
                        const independent_prob = row_marginal * col_marginal;
                        mutual_information += joint_prob * Math.log2(joint_prob / independent_prob);
                    }
                }
            }
            
            return mutual_information;
        }

        /**
         * Calculates normalized mutual information (NMI)
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {number} Normalized mutual information value (0-1 range)
         */
        function calculateNormalizedMutualInformation(matrix_values) {
            const mutual_info = calculateMutualInformation(matrix_values);
            
            // Calculate entropy for normalization
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            const total_sum = matrix_values.flat().reduce((sum, val) => sum + val, 0);
            if (total_sum === 0) {
                return 0;
            }
            
            let normalized_matrix = matrix_values;
            if (Math.abs(total_sum - 1.0) > 1e-10) {
                normalized_matrix = matrix_values.map(row => 
                    row.map(val => val / total_sum)
                );
            }
            
            // Calculate row and column entropies
            const row_marginals = normalized_matrix.map(row => 
                row.reduce((sum, val) => sum + val, 0)
            );
            
            const column_marginals = [];
            for (let col_index = 0; col_index < num_cols; col_index++) {
                let col_sum = 0;
                for (let row_index = 0; row_index < num_rows; row_index++) {
                    col_sum += normalized_matrix[row_index][col_index];
                }
                column_marginals.push(col_sum);
            }
            
            // Calculate entropies
            let row_entropy = 0;
            for (const prob of row_marginals) {
                if (prob > 0) {
                    row_entropy -= prob * Math.log2(prob);
                }
            }
            
            let col_entropy = 0;
            for (const prob of column_marginals) {
                if (prob > 0) {
                    col_entropy -= prob * Math.log2(prob);
                }
            }
            
            // Normalize MI by geometric mean of entropies
            const entropy_product = row_entropy * col_entropy;
            if (entropy_product === 0) {
                return 0;
            }
            
            return mutual_info / Math.sqrt(entropy_product);
        }

        /**
         * Calculates the information content from each classifier answer
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<number>} Information content for each predicted class in bits
         */
        function calculateClassifierAnswerInformation(matrix_values) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            // Calculate total sum for normalization
            const total_sum = matrix_values.flat().reduce((sum, val) => sum + val, 0);
            if (total_sum === 0) {
                return new Array(num_cols).fill(0);
            }
            
            // Calculate column marginals P(predicted = j)
            const column_marginals = [];
            for (let col_index = 0; col_index < num_cols; col_index++) {
                let col_sum = 0;
                for (let row_index = 0; row_index < num_rows; row_index++) {
                    col_sum += matrix_values[row_index][col_index];
                }
                column_marginals.push(col_sum / total_sum);
            }
            
            // Calculate row marginals P(true = i)
            const row_marginals = [];
            for (let row_index = 0; row_index < num_rows; row_index++) {
                let row_sum = 0;
                for (let col_index = 0; col_index < num_cols; col_index++) {
                    row_sum += matrix_values[row_index][col_index];
                }
                row_marginals.push(row_sum / total_sum);
            }
            
            // For each predicted class j, calculate I(True; Predicted=j)
            const information_per_answer = [];
            for (let col_index = 0; col_index < num_cols; col_index++) {
                let information = 0;
                
                if (column_marginals[col_index] > 0) {
                    // Calculate conditional probabilities P(true=i | predicted=j)
                    for (let row_index = 0; row_index < num_rows; row_index++) {
                        const joint_prob = matrix_values[row_index][col_index] / total_sum;
                        const conditional_prob = joint_prob / column_marginals[col_index];
                        const marginal_prob = row_marginals[row_index];
                        
                        if (conditional_prob > 0 && marginal_prob > 0) {
                            // I(True=i; Predicted=j) = log₂(P(true=i|pred=j) / P(true=i))
                            information += conditional_prob * Math.log2(conditional_prob / marginal_prob);
                        }
                    }
                }
                
                information_per_answer.push(information);
            }
            
            return information_per_answer;
        }

        /**
         * Calculates and displays matrix statistics
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization applied
         * @param {boolean} use_smoothing - Whether smoothing was applied
         * @param {number} alpha - Smoothing parameter used
         * side-effects: Modifies DOM element with id 'stats-container'
         */
        function displayMatrixStatistics(parsed_data, normalization_type = 'none', use_smoothing = false, alpha = 0.5) {
            const stats_container = document.getElementById('stats-container');
            
            // Use normalized matrix for statistics
            const display_matrix = applyNormalization(parsed_data.matrix_values, normalization_type, use_smoothing, alpha);
            
            // Calculate statistics
            const all_values = display_matrix.flat();
            const min_value = Math.min(...all_values);
            const max_value = Math.max(...all_values);
            const mean_value = all_values.reduce((sum, val) => sum + val, 0) / all_values.length;
            const matrix_dimensions = `${display_matrix.length}×${display_matrix[0].length}`;
            
            // Calculate trace and mutual information
            const trace_value = calculateTrace(display_matrix);
            const num_classes = Math.min(display_matrix.length, display_matrix[0].length);
            const normalized_trace = num_classes > 0 ? trace_value / num_classes : 0;
            const mutual_info = calculateMutualInformation(display_matrix);
            const normalized_mutual_info = calculateNormalizedMutualInformation(display_matrix);
            const answer_information = calculateClassifierAnswerInformation(display_matrix);
            
            // Create stat boxes
            const normalization_labels = (LANGUAGES[currentLanguage]?.strings?.normalizationNames) || {
                'none': 'Original',
                'row': 'Row Normalized',
                'column': 'Column Normalized', 
                'row_then_column': 'Row→Column',
                'sinkhorn_knopp': 'Sinkhorn-Knopp',
                'sum': 'Sum Normalized'
            };
            
            const statistics = [
                { label: t('matrixTitle'), value: normalization_labels[normalization_type], tooltip: '' },
                { label: t('stats.dimensions'), value: matrix_dimensions, tooltip: t('stats.dimensionsTip') },
                { label: t('stats.min'), value: min_value.toFixed(4), tooltip: t('stats.minTip') },
                { label: t('stats.max'), value: max_value.toFixed(4), tooltip: t('stats.maxTip') },
                { label: t('stats.mean'), value: mean_value.toFixed(4), tooltip: t('stats.meanTip') },
                { label: t('stats.trace'), value: trace_value.toFixed(4), tooltip: t('stats.traceTip') },
                { label: t('stats.tracePerClass'), value: normalized_trace.toFixed(4), tooltip: t('stats.tracePerClassTip') },
                { label: t('stats.mi'), value: mutual_info.toFixed(4), tooltip: t('stats.miTip') },
                { label: t('stats.nmi'), value: normalized_mutual_info.toFixed(4), tooltip: t('stats.nmiTip') }
            ];
            
            stats_container.innerHTML = '';
            
            for (const stat of statistics) {
                const stat_box = document.createElement('div');
                stat_box.className = 'stat-box';
                
                // Add tooltip if available
                if (stat.tooltip) {
                    stat_box.setAttribute('data-tooltip', stat.tooltip);
                }
                
                const label_element = document.createElement('h3');
                label_element.textContent = stat.label;
                
                const value_element = document.createElement('div');
                value_element.className = 'value';
                value_element.textContent = stat.value;
                
                stat_box.appendChild(label_element);
                stat_box.appendChild(value_element);
                stats_container.appendChild(stat_box);
            }
            
            stats_container.style.display = 'grid';
        }

        /**
         * Displays RAS decomposition for Sinkhorn-Knopp normalization
         * @param {Object} parsed_data - Parsed table data
         * @param {Object} decomposition - RAS decomposition result
         * side-effects: Modifies DOM element with id 'decomposition-container'
         */
        function displayDecomposition(parsed_data, decomposition) {
            const decomposition_container = document.getElementById('decomposition-container');
            
            // Create the display content
            const row_scaling_html = decomposition.row_scaling.map((value, index) => `
                <div class="scaling-item">
                    <span class="label">${parsed_data.row_labels[index]}:</span>
                    <span class="value">${value.toFixed(6)}</span>
                </div>
            `).join('');
            
            const column_scaling_html = decomposition.column_scaling.map((value, index) => `
                <div class="scaling-item">
                    <span class="label">${parsed_data.column_labels[index]}:</span>
                    <span class="value">${value.toFixed(6)}</span>
                </div>
            `).join('');
            
            decomposition_container.innerHTML = `
                <div class="decomposition-title" data-tooltip="${t('tooltips.rasTooltip')}">
                    ${t('tooltips.rasTitle')}
                </div>
                <div class="decomposition-content">
                    <div class="scaling-section">
                        <h4>${t('tooltips.rowScalingFactors')}</h4>
                        <div class="scaling-values">
                            ${row_scaling_html}
                        </div>
                    </div>
                    <div class="scaling-section">
                        <h4>${t('tooltips.columnScalingFactors')}</h4>
                        <div class="scaling-values">
                            ${column_scaling_html}
                        </div>
                    </div>
                    <div class="reconstruction-formula" data-tooltip="${t('tooltips.reconstructionTooltip')}">
                        ${t('tooltips.reconstructionFormula')}
                    </div>
                </div>
            `;
            
            decomposition_container.style.display = 'block';
        }

        /**
         * Hides the decomposition display
         * side-effects: Modifies DOM element with id 'decomposition-container'
         */
        function hideDecomposition() {
            const decomposition_container = document.getElementById('decomposition-container');
            decomposition_container.style.display = 'none';
            decomposition_container.innerHTML = '';
        }

        /**
         * Displays error message to user
         * @param {string} error_text - Error message to display
         * side-effects: Modifies DOM elements for error display
         */
        function showErrorMessage(error_text) {
            const error_element = document.getElementById('error-message');
            error_element.textContent = error_text;
            error_element.style.display = 'block';
            
            // Hide matrix, text view, decomposition, and stats
            document.getElementById('matrix-container').innerHTML = '';
            document.getElementById('text-view-container').innerHTML = '';
            document.getElementById('text-view-container').style.display = 'none';
            document.getElementById('decomposition-container').style.display = 'none';
            document.getElementById('stats-container').style.display = 'none';
        }

        /**
         * Hides error message
         * side-effects: Modifies DOM element with id 'error-message'
         */
        function hideErrorMessage() {
            const error_element = document.getElementById('error-message');
            error_element.style.display = 'none';
        }

        /**
         * Updates the matrix title based on normalization type
         * @param {string} normalization_type - Type of normalization applied
         * side-effects: Modifies DOM element with id 'matrix-title'
         */
        function updateMatrixTitle(normalization_type) {
            const title_element = document.getElementById('matrix-title');
            const normName = LANGUAGES?.[currentLanguage]?.strings?.normalizationNames?.[normalization_type];
            if (!normName) {
                console.error(`i18n: missing normalization name for '${normalization_type}'`);
                title_element.textContent = `${t('matrixTitle')} (${normalization_type})`;
                return;
            }
            title_element.textContent = `${t('matrixTitle')} (${normName})`;
        }

        /**
         * Main function to process table input and generate matrix visualization
         * side-effects: Updates DOM with matrix visualization or error message
         */
        function processTableInput() {
            const input_element = document.getElementById('table-input');
            const table_data = input_element.value.trim();
            
            if (!table_data) {
                showErrorMessage('Please enter table data');
                return;
            }
            
            try {
                hideErrorMessage();
                const parsed_data = parseTableData(table_data);
                
                // Show normalization options and matrix controls after successful parsing
                document.getElementById('normalization-section').style.display = 'block';
                document.getElementById('matrix-controls').style.display = 'flex';
                
                // Re-initialize tooltips for newly shown controls
                initializeTooltips();
                
                // Get selected normalization type and options
                const selected_normalization = document.querySelector('input[name="normalization"]:checked').value;
                const include_sums = document.getElementById('include-sums').checked;
                const include_info = document.getElementById('include-info').checked;
                const use_smoothing = document.getElementById('use-smoothing').checked;
                const alpha = parseFloat(document.getElementById('alpha-value').value);
                
                updateMatrixTitle(selected_normalization);
                renderConfusionMatrix(parsed_data, selected_normalization, include_sums, include_info, use_smoothing, alpha);
                renderTextView(parsed_data, selected_normalization, include_sums);
                displayMatrixStatistics(parsed_data, selected_normalization, use_smoothing, alpha);
                
                // Show decomposition only for Sinkhorn-Knopp normalization
                if (selected_normalization === 'sinkhorn_knopp') {
                    const decomposition = normalizeSinkhornKnopp(parsed_data.matrix_values, 100, 1e-6, true);
                    displayDecomposition(parsed_data, decomposition);
                } else {
                    hideDecomposition();
                }
            } catch (error) {
                showErrorMessage(`Error: ${error.message}`);
                // Hide normalization options and matrix controls on error
                document.getElementById('normalization-section').style.display = 'none';
                document.getElementById('matrix-controls').style.display = 'none';
            }
        }

        /**
         * Updates the matrix display when normalization type changes
         * side-effects: Re-renders matrix with new normalization
         */
        function updateMatrixNormalization() {
            const input_element = document.getElementById('table-input');
            const table_data = input_element.value.trim();
            
            if (!table_data) {
                return;
            }
            
            try {
                const parsed_data = parseTableData(table_data);
                const selected_normalization = document.querySelector('input[name="normalization"]:checked').value;
                const include_sums = document.getElementById('include-sums').checked;
                const include_info = document.getElementById('include-info').checked;
                const use_smoothing = document.getElementById('use-smoothing').checked;
                const alpha = parseFloat(document.getElementById('alpha-value').value);
                
                updateMatrixTitle(selected_normalization);
                renderConfusionMatrix(parsed_data, selected_normalization, include_sums, include_info, use_smoothing, alpha);
                renderTextView(parsed_data, selected_normalization, include_sums);
                displayMatrixStatistics(parsed_data, selected_normalization, use_smoothing, alpha);
                
                // Show decomposition only for Sinkhorn-Knopp normalization
                if (selected_normalization === 'sinkhorn_knopp') {
                    const decomposition = normalizeSinkhornKnopp(parsed_data.matrix_values, 100, 1e-6, true);
                    displayDecomposition(parsed_data, decomposition);
                } else {
                    hideDecomposition();
                }
            } catch (error) {
                // Error handling is already done in processTableInput
                console.error('Error updating normalization:', error);
            }
        }

        // Event listeners
        document.getElementById('parse-button').addEventListener('click', processTableInput);
        
        document.getElementById('table-input').addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 'Enter') {
                processTableInput();
            }
        });
        
        // Add event listener for alpha value input
        document.getElementById('alpha-value').addEventListener('input', function() {
            // Update matrix when alpha value changes
            updateMatrixNormalization();
        });
        
        // Add event listeners for normalization radio buttons
        document.addEventListener('change', function(event) {
            if (event.target.name === 'normalization') {
                updateMatrixNormalization();
            }
            if (event.target.id === 'include-sums') {
                updateMatrixNormalization();
            }
            if (event.target.id === 'include-info') {
                updateMatrixNormalization();
            }
            if (event.target.id === 'use-smoothing') {
                // Show/hide alpha input based on smoothing toggle
                const alpha_group = document.getElementById('alpha-input-group');
                alpha_group.style.display = event.target.checked ? 'flex' : 'none';
                updateMatrixNormalization();
            }
        });
        
        // Add event listeners for view mode buttons
        document.getElementById('table-view-btn').addEventListener('click', function() {
            document.getElementById('matrix-container').style.display = 'block';
            document.getElementById('text-view-container').style.display = 'none';
            
            document.getElementById('table-view-btn').classList.add('active');
            document.getElementById('text-view-btn').classList.remove('active');
        });
        
        document.getElementById('text-view-btn').addEventListener('click', function() {
            document.getElementById('matrix-container').style.display = 'none';
            document.getElementById('text-view-container').style.display = 'block';
            
            document.getElementById('text-view-btn').classList.add('active');
            document.getElementById('table-view-btn').classList.remove('active');
        });
        
        // Add event listener for CSV download
        document.getElementById('download-csv-btn').addEventListener('click', function() {
            const input_element = document.getElementById('table-input');
            const table_data = input_element.value.trim();
            
            if (!table_data) {
                alert('Please enter table data first');
                return;
            }
            
            try {
                const parsed_data = parseTableData(table_data);
                const selected_normalization = document.querySelector('input[name="normalization"]:checked').value;
                const include_sums = document.getElementById('include-sums').checked;
                
                downloadAsCSV(parsed_data, selected_normalization, include_sums);
            } catch (error) {
                alert(`Error generating CSV: ${error.message}`);
            }
        });

        // Load example data on page load
        // Make test function available globally for debugging
        window.runParserTests = runParserTests;

        /**
         * Initialize custom tooltips for elements with data-tooltip attribute
         */
        function initializeTooltips() {
            // Remove any existing tooltips
            const existing_tooltips = document.querySelectorAll('.custom-tooltip');
            existing_tooltips.forEach(tooltip => tooltip.remove());
            
            // Find all elements with data-tooltip
            const tooltip_elements = document.querySelectorAll('[data-tooltip]:not(.stat-box)');
            
            tooltip_elements.forEach(element => {
                element.addEventListener('mouseenter', function(event) {
                    // Create tooltip element
                    const tooltip = document.createElement('div');
                    tooltip.className = 'custom-tooltip';
                    tooltip.textContent = this.getAttribute('data-tooltip');
                    
                    // Style the tooltip
                    Object.assign(tooltip.style, {
                        position: 'fixed',
                        background: '#333',
                        color: 'white',
                        padding: '16px 20px',
                        borderRadius: '8px',
                        fontSize: '14px',
                        lineHeight: '1.5',
                        whiteSpace: 'pre-line',
                        zIndex: '9999',
                        opacity: '0.95',
                        maxWidth: '400px',
                        textAlign: 'left',
                        boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                        pointerEvents: 'none',
                        fontFamily: 'system-ui, -apple-system, sans-serif'
                    });
                    
                    // Position tooltip near mouse
                    const rect = this.getBoundingClientRect();
                    tooltip.style.left = (rect.left + rect.width / 2) + 'px';
                    tooltip.style.top = (rect.top - 10) + 'px';
                    tooltip.style.transform = 'translateX(-50%) translateY(-100%)';
                    
                    document.body.appendChild(tooltip);
                });
                
                element.addEventListener('mouseleave', function() {
                    const tooltips = document.querySelectorAll('.custom-tooltip');
                    tooltips.forEach(tooltip => tooltip.remove());
                });
            });
        }

        window.addEventListener('load', function() {
            const run_tests = false;
            
            if (run_tests) {
                // Run tests in console for debugging
                console.log('Running parser tests...');
                runParserTests();
            }
            
            // Load translations and init i18n
            loadTranslations().then(() => {
                const select = document.getElementById('language-select');
                if (select && select.value) currentLanguage = select.value;
                updateUILanguage();
                initializeTooltips();
            }).catch((e) => {
                console.error('i18n: failed to load translations', e);
            });

            // Language selector
            const languageSelect = document.getElementById('language-select');
            if (languageSelect) {
                languageSelect.addEventListener('change', function() {
                    currentLanguage = this.value;
                    updateUILanguage();
                    const selected_normalization = document.querySelector('input[name="normalization"]:checked');
                    if (!selected_normalization) {
                        console.error('i18n: normalization radio not found');
                        return;
                    }
                    updateMatrixTitle(selected_normalization.value);
                    // Re-render matrix/text/stats so dynamic row headers (e.g., Answer Info) are translated immediately
                    try {
                        updateMatrixNormalization();
                    } catch (e) {
                        console.error('i18n: failed to re-render after language change', e);
                    }
                });
            } else {
                console.error('i18n: language selector not found');
            }
            
            const example_data = t('exampleData');
            
            document.getElementById('table-input').value = example_data;
            processTableInput();
        });
    </script>
</body>
</html>
