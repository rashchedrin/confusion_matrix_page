<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Confusion Matrix Viewer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .language-selector label {
            font-size: 20px;
            margin: 0;
        }

        .language-selector select {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .language-selector select:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .language-selector select:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .template-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .template-selector label {
            font-size: 14px;
            font-weight: 600;
            color: #555;
        }

        .template-selector select {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .template-selector select:focus {
            outline: none;
            border-color: #667eea;
        }

        .template-save-section {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .template-save-section label {
            font-size: 14px;
            font-weight: 600;
            color: #555;
        }

        #template-title-input {
            flex: 1;
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        #template-title-input:focus {
            outline: none;
            border-color: #667eea;
        }

        #save-template-btn {
            padding: 6px 16px;
            border: none;
            border-radius: 6px;
            background: #667eea;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #save-template-btn:hover {
            background: #5568d3;
        }

        #save-template-btn:active {
            background: #4457c2;
        }

        #delete-template-btn {
            padding: 6px 16px;
            border: none;
            border-radius: 6px;
            background: #e53e3e;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: none;
        }

        #delete-template-btn:hover {
            background: #c53030;
        }

        #delete-template-btn:active {
            background: #9b2c2c;
        }

        #table-input {
            width: 100%;
            height: 150px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        #table-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-container {
            margin-top: 15px;
            text-align: center;
        }

        #parse-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        #parse-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.3);
        }

        #parse-button:active {
            transform: translateY(0);
        }

        .matrix-section {
            margin-top: 30px;
        }

        .matrix-section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        .confusion-matrix {
            margin: 0 auto;
            border-collapse: collapse;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        .confusion-matrix th {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #495057;
            padding: 12px 15px;
            font-weight: 600;
            text-align: center;
            border: 1px solid #dee2e6;
            font-size: 14px;
        }

        .confusion-matrix th.corner {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
        }

        .confusion-matrix th.row-header {
            background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            text-align: right;
            font-weight: 600;
        }

        .confusion-matrix td {
            padding: 12px 15px;
            text-align: center;
            border: 1px solid #dee2e6;
            font-weight: 500;
            font-size: 13px;
            color: #333;
            min-width: 80px;
        }

        .normalization-section {
            margin-top: 25px;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .normalization-section h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .normalization-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 10px 15px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 25px;
            transition: all 0.3s ease;
            min-width: 200px;
        }

        .radio-option:hover {
            border-color: #667eea;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.1);
        }

        .radio-option input[type="radio"] {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .radio-option input[type="radio"]:checked + span {
            font-weight: 600;
            color: #667eea;
        }

        .radio-option:has(input[type="radio"]:checked) {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
        }

        .matrix-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border: 1px solid #dee2e6;
            align-items: flex-start;
            justify-content: flex-start;
            max-width: 100%;
            box-sizing: border-box;
            overflow: visible;
            position: relative;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            flex: 0 1 auto;
            min-width: 160px;
            max-width: 220px;
            min-height: 70px;
            position: relative;
            overflow: visible;
            justify-content: flex-start;
        }

        .control-group label {
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }

        .toggle-switch {
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: relative;
            cursor: pointer;
            width: 50px;
            height: 24px;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 24px;
            flex-shrink: 0;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .label-text {
            margin: 0;
            font-size: 14px;
            font-weight: 500;
            color: #495057;
            flex-grow: 1;
        }

        .view-mode-buttons {
            display: flex;
            gap: 5px;
            width: 100%;
            max-width: 100%;
        }

        .view-btn {
            padding: 8px 8px;
            border: 2px solid #dee2e6;
            background: white;
            color: #495057;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            flex: 1;
            text-align: center;
            min-width: 0;
        }

        .view-btn:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .view-btn.active {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }

        .download-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .download-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
        }

        .share-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 10px;
        }

        .share-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 10px;
            width: 90%;
            max-width: 600px;
            position: relative;
        }

        .modal-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 15px;
            top: 10px;
        }

        .modal-close:hover,
        .modal-close:focus {
            color: #000;
        }

        .share-link-input-group {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        #share-link-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: monospace;
            word-break: break-all;
        }

        .copy-btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.3s ease;
        }

        .copy-btn:hover {
            background: #5568d3;
        }

        .share-link-copied {
            color: #28a745;
            font-size: 14px;
            margin-top: 10px;
            font-weight: 600;
        }

        .text-view-container {
            margin-bottom: 20px;
        }

        .text-view-content {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        .copy-text-btn {
            margin-top: 10px;
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }

        .copy-text-btn:hover {
            background: #5a6268;
        }

        .alpha-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
            padding: 8px 12px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            transition: all 0.3s ease;
            width: fit-content;
            position: relative;
        }

        .alpha-input-group label {
            font-size: 13px;
            font-weight: 600;
            color: #495057;
            margin: 0;
        }

        .alpha-input-group input {
            width: 60px;
            padding: 3px 6px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }

        .alpha-input-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.25);
        }

        .decomposition-container {
            margin: 20px 0;
            padding: 20px;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 1px solid #90caf9;
            border-radius: 8px;
        }

        .decomposition-title {
            color: #1565c0;
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }

        .decomposition-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .scaling-section {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #90caf9;
        }

        .scaling-section h4 {
            color: #1565c0;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .scaling-values {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .scaling-item {
            background: #f8f9fa;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .scaling-item .label {
            font-weight: 600;
            color: #495057;
        }

        .scaling-item .value {
            color: #1565c0;
            margin-left: 5px;
        }

        .reconstruction-formula {
            grid-column: 1 / -1;
            background: #fff3e0;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ffb74d;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #e65100;
            font-weight: 600;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #f5c6cb;
            margin-top: 15px;
            display: none;
        }

        .stats-container {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        .prior-frequencies-section {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }

        .prior-frequencies-header {
            cursor: pointer;
            user-select: none;
            font-weight: 600;
            color: #495057;
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .prior-frequencies-header:hover {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }

        .prior-frequencies-header::before {
            content: '‚ñ∂';
            transition: transform 0.2s;
            display: inline-block;
        }

        .prior-frequencies-section.expanded .prior-frequencies-header::before {
            transform: rotate(90deg);
        }

        .prior-frequencies-content {
            display: none;
            margin-top: 10px;
        }

        .prior-frequencies-section.expanded .prior-frequencies-content {
            display: block;
        }

        #prior-frequencies-input {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        #prior-frequencies-input.error {
            border-color: #dc3545;
            background-color: #fff5f5;
        }

        .prior-frequencies-error {
            color: #dc3545;
            font-size: 13px;
            margin-top: 5px;
            padding: 5px 10px;
            background-color: #fff5f5;
            border-left: 3px solid #dc3545;
            border-radius: 3px;
            display: none;
        }

        .prior-frequencies-error.show {
            display: block;
        }

        .stat-box {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            text-align: center;
            position: relative;
            cursor: help;
        }

        .stat-box[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: normal;
            word-wrap: break-word;
            max-width: min(300px, calc(100vw - 20px));
            width: max-content;
            z-index: 1000;
            opacity: 0.95;
            margin-bottom: 5px;
            box-sizing: border-box;
        }

        .stat-box[data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #333;
            margin-bottom: -5px;
        }

        /* Tooltips handled by JavaScript - CSS tooltips disabled */
        [data-tooltip]:hover {
            cursor: help;
        }

        /* Mobile-specific adjustments */
        @media (hover: none) {
            [data-tooltip] {
                cursor: default;
            }
        }

        /* Horizontal scroll for wide matrices */
        #matrix-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        #matrix-container table {
            width: max-content;
            max-width: none;
        }

        /* Info button for mobile */
        .info-btn {
            display: inline-flex;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #1976d2;
            color: #fff;
            font-weight: 700;
            font-size: 12px;
            align-items: center;
            justify-content: center;
            margin-left: 6px;
            line-height: 1;
            cursor: pointer;
            user-select: none;
        }

        /* Fullscreen modal for tooltip content on mobile */
        .mobile-info-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 10000;
            display: flex;
            align-items: stretch;
            justify-content: center;
        }
        .mobile-info-modal .modal-content {
            background: #fff;
            color: #212529;
            width: 100%;
            max-width: 680px;
            height: 100%;
            overflow: auto;
            padding: 16px 20px 24px;
            box-sizing: border-box;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .mobile-info-modal .modal-header {
            position: sticky;
            top: 0;
            background: #fff;
            padding-bottom: 8px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #e9ecef;
            z-index: 1;
        }
        .mobile-info-modal .modal-title {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
            color: #343a40;
        }
        .mobile-info-modal .close-btn {
            background: transparent;
            border: none;
            font-size: 24px;
            line-height: 1;
            cursor: pointer;
            color: #495057;
        }

        .stat-box h3 {
            color: #495057;
            font-size: 0.9em;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-box .value {
            font-size: 1.2em;
            font-weight: 600;
            color: #667eea;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 5px;
            }
            
            .content {
                padding: 20px;
            }
            
            .confusion-matrix {
                font-size: 12px;
            }
            
            .confusion-matrix th,
            .confusion-matrix td {
                padding: 8px 10px;
                min-width: 60px;
            }
            
            .matrix-controls {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }
            
            .control-group {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
                min-height: auto;
                min-width: auto;
                max-width: 100%;
                width: 100%;
            }
            
            .toggle-switch {
                width: auto;
                justify-content: space-between;
            }
            
            .normalization-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .radio-option {
                min-width: auto;
                justify-content: center;
            }
            
            .decomposition-content {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .scaling-values {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="position: relative;">
            <div class="language-selector">
                <label for="language-select">üåê</label>
                <select id="language-select">
                    <option value="en">English</option>
                    <option value="ru">–†—É—Å—Å–∫–∏–π</option>
                </select>
            </div>
            <h1>Confusion Matrix Viewer</h1>
            <p>Paste your tab-separated table data and visualize it as a color-coded confusion matrix</p>
        </div>
        
        <div class="content">
            <div class="input-section">
                <h2>Input Data</h2>
                <div class="template-selector">
                    <label for="template-select">Template:</label>
                    <select id="template-select">
                        <option value="multiclass">Multi-class classifier</option>
                        <option value="all_positive">All positive (noninformative)</option>
                        <option value="one_percent_positive">1% positive (noninformative)</option>
                    </select>
                </div>
                <div class="template-save-section">
                    <label for="template-title-input">Title:</label>
                    <input type="text" id="template-title-input" placeholder="Enter template name">
                    <button id="save-template-btn">Save in local storage</button>
                    <button id="delete-template-btn">Delete</button>
                </div>
                <textarea id="table-input" placeholder=""></textarea>
                <div class="button-container">
                    <button id="parse-button">Generate Confusion Matrix</button>
                </div>
                
                <div class="normalization-section" id="normalization-section" style="display: none;">
                    <h3>Normalization Options</h3>
                    <div class="normalization-controls">
                        <label class="radio-option" data-tooltip="Original confusion matrix showing raw counts or frequencies.

Interpretation:
‚Ä¢ Each cell [i,j] = number of instances where true class was i and predicted class was j
‚Ä¢ Row sums = total instances per true class
‚Ä¢ Column sums = total instances per predicted class
‚Ä¢ Diagonal elements = correctly classified instances
‚Ä¢ Off-diagonal elements = misclassifications

Use when: You want to see absolute numbers and class imbalances.">
                            <input type="radio" name="normalization" value="none" checked>
                            <span>Original (No normalization)</span>
                        </label>
                        <label class="radio-option" data-tooltip="Row-normalized matrix showing conditional probabilities P(Predicted | True).

Interpretation:
‚Ä¢ Each cell [i,j] = probability of predicting class j given true class i
‚Ä¢ Each row sums to 1.0 (probability distribution)
‚Ä¢ Diagonal elements = per-class recall (sensitivity)
‚Ä¢ Off-diagonal elements = per-class confusion rates
‚Ä¢ Removes class imbalance effects

Use when: You want to analyze classifier performance per true class, compare recall across classes, or when classes have different frequencies.

Example: Cell [Cat, Dog] = 0.15 means 15% of cats were misclassified as dogs.">
                            <input type="radio" name="normalization" value="row">
                            <span>Normalized by truth (rows)</span>
                        </label>
                        <label class="radio-option" data-tooltip="Column-normalized matrix showing conditional probabilities P(True | Predicted).

Interpretation:
‚Ä¢ Each cell [i,j] = probability that true class is i given prediction j
‚Ä¢ Each column sums to 1.0 (probability distribution)
‚Ä¢ Diagonal elements = per-class precision (positive predictive value)
‚Ä¢ Off-diagonal elements = per-prediction confusion rates
‚Ä¢ Shows reliability of predictions

IMPORTANT: These are true posterior probabilities P(True | Predicted) ONLY if the test samples come from the same distribution as the training/validation data used to create this confusion matrix.

Use when: You want to analyze prediction reliability under the assumption that future data matches current test distribution.

Example: Cell [Cat, Dog] = 0.20 means 20% of 'Dog' predictions were actually cats (in this dataset).">
                            <input type="radio" name="normalization" value="column">
                            <span>Normalized by prediction (columns)</span>
                        </label>
                        <label class="radio-option" data-tooltip="Sequential normalization: first by truth (rows), then by prediction (columns).

Interpretation:
‚Ä¢ Step 1: Row normalization creates P(Predicted | True)
‚Ä¢ Step 2: Column normalization creates posterior probabilities P(True | Predicted) under uniform prior
‚Ä¢ Columns sum to 1.0 (posterior probability distributions)
‚Ä¢ Rows do not sum to 1.0 (balanced by uniform prior assumption)
‚Ä¢ Represents Bayesian inference assuming equal class priors

Use when: You want posterior probabilities assuming uniform class distribution, remove original class frequency bias, or analyze classifier output under balanced prior assumptions.

Bayesian interpretation: Converts classifier outputs to posterior probabilities assuming P(True class) is uniform across all classes.">
                            <input type="radio" name="normalization" value="row_then_column">
                            <span>Truth then prediction normalized</span>
                        </label>
                        <label class="radio-option" data-tooltip="Doubly stochastic matrix via iterative Sinkhorn-Knopp algorithm.

Interpretation:
‚Ä¢ Each row AND each column sums to 1.0 simultaneously
‚Ä¢ Creates a balanced joint probability distribution P(True, Predicted)
‚Ä¢ Preserves relative confusion patterns while removing all bias
‚Ä¢ Converges to optimal transport solution
‚Ä¢ Matrix may not be symmetric (asymmetry has meaning)

Use when: You want to analyze pure confusion patterns without any class frequency or prediction bias effects, study classifier behavior in idealized balanced scenarios.

Mathematical: Finds row scaling r and column scaling c such that diag(r) √ó Original √ó diag(c) is doubly stochastic.

Asymmetry interpretation: Reflects inherent directional confusion patterns between classes.">
                            <input type="radio" name="normalization" value="sinkhorn_knopp">
                            <span>Sinkhorn-Knopp normalized</span>
                        </label>
                        <label class="radio-option" data-tooltip="Matrix normalized by total sum, creating a joint probability distribution.

Interpretation:
‚Ä¢ Each cell [i,j] = P(True=i AND Predicted=j)
‚Ä¢ All cells sum to 1.0 (complete probability space)
‚Ä¢ Diagonal elements = P(correct classification)
‚Ä¢ Off-diagonal elements = P(specific misclassification types)
‚Ä¢ Preserves original class frequency information

Use when: You want to analyze the overall probability distribution of classification outcomes, study the likelihood of specific confusion types, or maintain class frequency relationships.

Example: Cell [Cat, Dog] = 0.05 means 5% of all classifications are 'cats predicted as dogs'.">
                            <input type="radio" name="normalization" value="sum">
                            <span>Sum normalized</span>
                        </label>
                        <label class="radio-option" data-tooltip="Prior-normalized matrix: truth-normalized (rows) multiplied by prior frequencies.

Interpretation:
‚Ä¢ Step 1: Row normalization creates P(Predicted | True)
‚Ä¢ Step 2: Each row multiplied by corresponding prior frequency P(True=i)
‚Ä¢ Result: P(Predicted | True) √ó P(True) = P(Predicted AND True) with specified priors
‚Ä¢ Rows sum to prior frequencies (not 1.0)
‚Ä¢ Columns sum to P(Predicted) under specified priors

Use when: You want to see confusion matrix under specific prior class distribution assumptions, or analyze classifier performance with custom class frequencies.

Bayesian interpretation: Shows joint distribution P(True, Predicted) assuming specified prior P(True).">
                            <input type="radio" name="normalization" value="prior">
                            <span>Prior normalized</span>
                        </label>
                        <label class="radio-option" data-tooltip="Prior then prediction normalized: truth-normalized (rows) multiplied by prior frequencies, then column-normalized.

Interpretation:
‚Ä¢ Step 1: Row normalization creates P(Predicted | True)
‚Ä¢ Step 2: Each row multiplied by corresponding prior frequency P(True=i)
‚Ä¢ Step 3: Column normalization creates posterior probabilities P(True | Predicted) under specified prior
‚Ä¢ Columns sum to 1.0 (posterior probability distributions)
‚Ä¢ Rows do not sum to 1.0 (balanced by specified prior assumption)
‚Ä¢ Represents Bayesian inference with custom class priors

Use when: You want posterior probabilities assuming specified class distribution, remove original class frequency bias, or analyze classifier output under custom prior assumptions.

Bayesian interpretation: Converts classifier outputs to posterior probabilities assuming P(True class) matches specified priors.">
                            <input type="radio" name="normalization" value="prior_then_column">
                            <span>Prior then prediction normalized</span>
                        </label>
                    </div>
                </div>
                <div id="error-message" class="error-message"></div>
            </div>
            
            <div class="matrix-section">
                <h2 id="matrix-title">Confusion Matrix</h2>
                
                <div class="matrix-controls" id="matrix-controls" style="display: none;">
                    <div class="control-group">
                        <label class="toggle-switch">
                            <input type="checkbox" id="include-sums" checked>
                            <span class="slider"></span>
                            <span class="label-text">Include row/column sums</span>
                        </label>
                    </div>
                    
                    <div class="control-group">
                        <label class="toggle-switch">
                            <input type="checkbox" id="include-info" checked>
                            <span class="slider"></span>
                            <span class="label-text">Include answer information</span>
                        </label>
                    </div>
                    
                    <div class="control-group">
                        <label class="toggle-switch" data-tooltip="Additive smoothing (Laplace smoothing) adds pseudocounts to handle zero probabilities and improve estimates:

‚Ä¢ Essential for epistemologically correct probabilities estimation
‚Ä¢ Prevents division by zero in probability calculations
‚Ä¢ Provides more robust statistical estimates
‚Ä¢ Essential for reliable mutual information computation
‚Ä¢ Recommended for sparse confusion matrices

The Œ± parameter controls the amount of smoothing applied.">
                            <input type="checkbox" id="use-smoothing" checked>
                            <span class="slider"></span>
                            <span class="label-text">Additive smoothing</span>
                        </label>
                        <div class="smoothing-options" id="smoothing-options" style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center;">
                            <select id="smoothing-type" style="padding: 3px 6px; border-radius: 4px; border: 1px solid #ddd;" data-tooltip="Smoothing type:

Uniform: Adds same pseudocount Œ± to every cell. Classic Laplace/Jeffrey's smoothing.

Hierarchical: Pseudocount[i,j] = k √ó prior_œÄ_i √ó prediction_œÄ_j
Structured smoothing based on marginal distributions.
Prior belief: classifier is noninformative (independent).">
                                <option value="uniform">Uniform</option>
                                <option value="hierarchical">Hierarchical</option>
                            </select>
                        <div class="alpha-input-group" id="alpha-input-group" style="display: flex;">
                            <label for="alpha-value">Œ± =</label>
                            <input type="number" id="alpha-value" min="0" max="10" step="0.1" value="0.5" data-tooltip="Alpha parameter (pseudocounts added to each cell):

Œ± = 0.5 (Jeffrey's Prior - RECOMMENDED):
‚Ä¢ Non-informative Bayesian prior for Dirichlet distribution
‚Ä¢ Scale-invariant and transformation-invariant
‚Ä¢ Minimal bias while handling zero counts
‚Ä¢ Theoretically optimal for unknown distributions

Œ± = 1.0 (Laplace's Rule of Succession):
‚Ä¢ Uniform prior assuming all outcomes equally likely
‚Ä¢ Classic approach, easy to interpret
‚Ä¢ Good when no prior knowledge exists
‚Ä¢ Adds exactly 1 pseudocount per cell

Œ± = 0 (No smoothing):
‚Ä¢ Uses original counts without modification
‚Ä¢ May cause issues with zero entries

Higher Œ± values = more smoothing = more conservative estimates">
                            </div>
                            <div class="hierarchical-params" id="hierarchical-params" style="display: none; gap: 8px; align-items: center;">
                                <label for="k-value" style="font-size: 13px;">k =</label>
                                <input type="number" id="k-value" min="0" max="100" step="0.1" value="0.5" style="width: 55px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;" data-tooltip="k parameter (total pseudocount mass):

k = 0.5 (RECOMMENDED):
‚Ä¢ Similar to Jeffrey's prior in total mass
‚Ä¢ Distributed according to marginals

Higher k = stronger prior toward independence model">
                                <label for="alpha-prior" style="font-size: 13px; margin-left: 8px;">Œ±_prior =</label>
                                <input type="number" id="alpha-prior" min="0" max="10" step="0.1" value="0.5" style="width: 55px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;" data-tooltip="Smoothing for prior (row) marginal estimation:

Œ±_prior = 0.5 (RECOMMENDED):
‚Ä¢ Jeffrey's prior for row marginal estimation
‚Ä¢ Handles zero row sums gracefully">
                                <label for="alpha-prediction" style="font-size: 13px; margin-left: 8px;">Œ±_pred =</label>
                                <input type="number" id="alpha-prediction" min="0" max="10" step="0.1" value="0.5" style="width: 55px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;" data-tooltip="Smoothing for prediction (column) marginal estimation:

Œ±_pred = 0.5 (RECOMMENDED):
‚Ä¢ Jeffrey's prior for column marginal estimation
‚Ä¢ Handles zero column sums gracefully">
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label>View Mode:</label>
                        <div class="view-mode-buttons">
                            <button id="table-view-btn" class="view-btn active">Table View</button>
                            <button id="text-view-btn" class="view-btn">Tab-separated Text</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <button id="download-csv-btn" class="download-btn">Download as CSV</button>
                        <button id="share-link-btn" class="share-btn">Share link</button>
                    </div>
                </div>
                
                <!-- Share Link Modal -->
                <div id="share-link-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <span class="modal-close">&times;</span>
                        <h3 id="share-link-modal-title">Shareable Link</h3>
                        <p id="share-link-modal-description">Copy this link to share your confusion matrix with all settings:</p>
                        <div class="share-link-input-group">
                            <input type="text" id="share-link-input" readonly>
                            <button id="copy-link-btn" class="copy-btn">Copy</button>
                        </div>
                        <p id="share-link-copied" class="share-link-copied" style="display: none;">Link copied to clipboard!</p>
                    </div>
                </div>
                
                <div id="matrix-container"></div>
                <div id="text-view-container" class="text-view-container" style="display: none;"></div>
                <div id="decomposition-container" class="decomposition-container" style="display: none;"></div>
                <div id="stats-container" class="stats-container" style="display: none;"></div>
                
                <div class="prior-frequencies-section" id="prior-frequencies-section" style="display: none;">
                    <div class="prior-frequencies-header" id="prior-frequencies-header">Prior frequencies</div>
                    <div class="prior-frequencies-content">
                        <textarea id="prior-frequencies-input" placeholder='{"class1": 1, "class2": 1, "class3": 1}'></textarea>
                        <div class="prior-frequencies-error" id="prior-frequencies-error"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="translations.js"></script>
    <script>
        /**
         * Throws an error if condition is false
         * @param {boolean} condition - Condition to check
         * @param {string} message - Error message if assertion fails
         * @throws {Error} If condition is false
         */
        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        // i18n
        let LANGUAGES = {};
        let currentLanguage = 'en';

        async function loadTranslations() {
            return new Promise((resolve) => {
                // Prefer window.LANGUAGES populated by translations.js
                if (window.LANGUAGES && Object.keys(window.LANGUAGES).length > 0) {
                    LANGUAGES = window.LANGUAGES;
                    resolve();
                    return;
                }
                // Fallback: check inline <script id="translations-json"> with JSON content
                const inline = document.getElementById('translations-json');
                if (inline && inline.textContent) {
                    try {
                        window.LANGUAGES = JSON.parse(inline.textContent);
                        LANGUAGES = window.LANGUAGES;
                    } catch (e) {
                        console.error('Failed to parse inline translations:', e);
                        window.LANGUAGES = {};
                        LANGUAGES = {};
                    }
                }
                resolve();
            });
        }

        function t(key) {
            const parts = key.split('.');
            let obj = LANGUAGES?.[currentLanguage]?.strings;
            if (!obj) {
                console.error(`i18n: language '${currentLanguage}' not loaded`);
                return '';
            }
            for (const part of parts) {
                if (obj && Object.prototype.hasOwnProperty.call(obj, part)) {
                    obj = obj[part];
                } else {
                    console.error(`i18n: missing key '${key}' for language '${currentLanguage}'`);
                    return '';
                }
            }
            if (typeof obj !== 'string') {
                console.error(`i18n: value for key '${key}' is not a string in language '${currentLanguage}'`);
                return '';
            }
            return obj;
        }

        function updateUILanguage() {
            const headerTitle = document.querySelector('.header h1');
            if (headerTitle) headerTitle.textContent = t('pageTitle');
            const headerSub = document.querySelector('.header p');
            if (headerSub) headerSub.textContent = t('pageSubtitle');

            const inputTitle = document.querySelector('.input-section h2');
            if (inputTitle) inputTitle.textContent = t('inputDataTitle');
            
            // Update template selector
            const templateLabel = document.querySelector('.template-selector label');
            if (templateLabel) templateLabel.textContent = t('templateLabel');
            const templateSelect = document.getElementById('template-select');
            if (templateSelect) {
                const options = templateSelect.querySelectorAll('option');
                if (options.length >= 3) {
                    options[0].textContent = t('templates.multiclass');
                    options[1].textContent = t('templates.allPositive');
                    options[2].textContent = t('templates.onePercentPositive');
                }
            }
            
            // Update template save section
            const templateTitleLabel = document.querySelector('.template-save-section label');
            if (templateTitleLabel) templateTitleLabel.textContent = t('templateTitleLabel');
            const saveTemplateBtn = document.getElementById('save-template-btn');
            if (saveTemplateBtn) saveTemplateBtn.textContent = t('saveTemplateButton');
            const deleteTemplateBtn = document.getElementById('delete-template-btn');
            if (deleteTemplateBtn) deleteTemplateBtn.textContent = t('deleteTemplateButton');
            
            const textarea = document.getElementById('table-input');
            if (textarea) {
                textarea.placeholder = t('inputPlaceholder');

                // Update template data in textarea if it contains any known template
                const currentValue = textarea.value.trim();
                const templateSelect = document.getElementById('template-select');
                const selectedTemplate = templateSelect ? templateSelect.value : 'multiclass';
                
                // Collect all template data from all languages
                const allTemplateData = [];
                for (const lang of Object.keys(LANGUAGES)) {
                    const langStrings = LANGUAGES[lang]?.strings;
                    if (langStrings?.exampleData) allTemplateData.push(langStrings.exampleData);
                    if (langStrings?.templateData) {
                        for (const key of Object.keys(langStrings.templateData)) {
                            allTemplateData.push(langStrings.templateData[key]);
                        }
                    }
                }

                // If current value is a known template (in any language), update it
                if (allTemplateData.includes(currentValue)) {
                    const template_map = {
                        'multiclass': 'multiclass',
                        'all_positive': 'allPositive',
                        'one_percent_positive': 'onePercentPositive'
                    };
                    const translation_key = template_map[selectedTemplate];
                    textarea.value = t('templateData.' + translation_key) || t('exampleData');
                    // Re-process the input to update the matrix display
                    if (typeof processTableInput === 'function') {
                        processTableInput();
                    }
                }
            }
            const genBtn = document.getElementById('parse-button');
            if (genBtn) genBtn.textContent = t('generateButton');

            const normTitle = document.querySelector('.normalization-section h3');
            if (normTitle) normTitle.textContent = t('normalizationTitle');
            const radioOptions = document.querySelectorAll('.normalization-controls .radio-option');
            if (radioOptions.length >= 8) {
                radioOptions[0].querySelector('span').textContent = t('normOriginal');
                radioOptions[1].querySelector('span').textContent = t('normRow');
                radioOptions[2].querySelector('span').textContent = t('normColumn');
                radioOptions[3].querySelector('span').textContent = t('normRowColumn');
                radioOptions[4].querySelector('span').textContent = t('normSinkhorn');
                radioOptions[5].querySelector('span').textContent = t('normSum');
                radioOptions[6].querySelector('span').textContent = t('normPrior');
                radioOptions[7].querySelector('span').textContent = t('normPriorThenColumn');

                // tooltips
                radioOptions[0].setAttribute('data-tooltip', t('tooltips.original'));
                radioOptions[1].setAttribute('data-tooltip', t('tooltips.rowNorm'));
                radioOptions[2].setAttribute('data-tooltip', t('tooltips.columnNorm'));
                radioOptions[3].setAttribute('data-tooltip', t('tooltips.rowColumnNorm'));
                radioOptions[4].setAttribute('data-tooltip', t('tooltips.sinkhornNorm'));
                radioOptions[5].setAttribute('data-tooltip', t('tooltips.sumNorm'));
                radioOptions[6].setAttribute('data-tooltip', t('tooltips.priorNorm'));
                radioOptions[7].setAttribute('data-tooltip', t('tooltips.priorThenColumnNorm'));
            }

            // Controls
            const labelTexts = document.querySelectorAll('.label-text');
            if (labelTexts.length >= 3) {
                labelTexts[0].textContent = t('includeRowColumnSums');
                labelTexts[1].textContent = t('includeAnswerInfo');
                // Compose detailed tooltip for the toggle
                const toggleTooltip = t('tooltips.answerInfo') + '\n\n' + t('tooltips.answerInfoMethod') + '\n\n' + t('tooltips.answerInfoMaxMethod');
                labelTexts[1].parentElement?.setAttribute?.('data-tooltip', toggleTooltip);
                labelTexts[2].textContent = t('additiveSmoothing');
            }
            const smoothingInput = document.getElementById('use-smoothing');
            const smoothingToggle = smoothingInput ? smoothingInput.parentElement : null;
            if (smoothingToggle) smoothingToggle.setAttribute('data-tooltip', t('tooltips.smoothingToggle'));
            const alphaInput = document.getElementById('alpha-value');
            if (alphaInput) alphaInput.setAttribute('data-tooltip', t('tooltips.alphaParam'));
            
            // Smoothing type selector
            const smoothingTypeSelect = document.getElementById('smoothing-type');
            if (smoothingTypeSelect) {
                const options = smoothingTypeSelect.querySelectorAll('option');
                if (options.length >= 2) {
                    options[0].textContent = t('tooltips.smoothingTypeUniform');
                    options[1].textContent = t('tooltips.smoothingTypeHierarchical');
                }
                smoothingTypeSelect.setAttribute('data-tooltip', t('tooltips.hierarchicalSmoothing'));
            }
            const kInput = document.getElementById('k-value');
            if (kInput) kInput.setAttribute('data-tooltip', t('tooltips.kParam'));

            // View mode
            const viewModeLabels = document.querySelectorAll('.control-group label');
            for (let label of viewModeLabels) {
                if (label.textContent && label.textContent.includes('View Mode')) {
                    label.textContent = t('viewMode');
                    break;
                }
            }
            const viewButtons = document.querySelectorAll('.view-btn');
            if (viewButtons.length >= 2) {
                viewButtons[0].textContent = t('tableView');
                viewButtons[1].textContent = t('tabSeparatedText');
            }
            const downloadBtn = document.getElementById('download-csv-btn');
            if (downloadBtn) downloadBtn.textContent = t('downloadCSV');
            const shareBtn = document.getElementById('share-link-btn');
            if (shareBtn) shareBtn.textContent = t('shareLink');
            
            // Update share link modal translations
            const shareModalTitle = document.getElementById('share-link-modal-title');
            if (shareModalTitle) shareModalTitle.textContent = t('shareLinkModalTitle');
            const shareModalDescription = document.getElementById('share-link-modal-description');
            if (shareModalDescription) shareModalDescription.textContent = t('shareLinkModalDescription');
            const copyBtn = document.getElementById('copy-link-btn');
            if (copyBtn) copyBtn.textContent = t('copyLink');
            const linkCopiedMsg = document.getElementById('share-link-copied');
            if (linkCopiedMsg) linkCopiedMsg.textContent = t('linkCopied');

            initializeTooltips();
        }
        /**
         * Tests the table parser with various input formats
         * @returns {boolean} True if all tests pass
         */
        function runParserTests() {
            const tests = [
                {
                    name: "Tab-separated with Russian labels",
                    input: `–ñ–∏—Ä–∞—Ñ\t–ù–æ—Å–æ—Ä–æ–≥\t–ö—Ä–∞–±\n1\t0\t0\n0\t1\t0\n0\t0\t1`,
                    expected: { rows: 3, cols: 3 }
                },
                {
                    name: "Space-separated with Russian labels",
                    input: `–ñ–∏—Ä–∞—Ñ –ù–æ—Å–æ—Ä–æ–≥ –ö—Ä–∞–±\n1 0 0\n0 1 0\n0 0 1`,
                    expected: { rows: 3, cols: 3 }
                },
                {
                    name: "User's failing case (header tabs, data spaces)",
                    input: `–ñ–∏—Ä–∞—Ñ\t–ù–æ—Å–æ—Ä–æ–≥\t–ö—Ä–∞–±\t\n1    0    0\n0    1    0  \n0    0    1`,
                    expected: { rows: 3, cols: 3 }
                },
                {
                    name: "Mixed separators per line (tabs and spaces)",
                    input: `A\tB\tC\n1 2 3\n4\t5\t6`,
                    expected: { rows: 2, cols: 3 }
                },
                {
                    name: "Pure space-separated (no tabs)",
                    input: `–ñ–∏—Ä–∞—Ñ –ù–æ—Å–æ—Ä–æ–≥ –ö—Ä–∞–± \n1 0 0\n0 1 0  \n0 0 1`,
                    expected: { rows: 3, cols: 3 }
                },
                {
                    name: "Multiple spaces",
                    input: `Class1    Class2    Class3\n0.85      0.10      0.05\n0.15      0.80      0.05`,
                    expected: { rows: 2, cols: 3 }
                },
                {
                    name: "Tab with trailing whitespace",
                    input: `–ñ–∏—Ä–∞—Ñ\t–ù–æ—Å–æ—Ä–æ–≥\t–ö—Ä–∞–±\t\n1\t0\t0\n0\t1\t0\n0\t0\t1`,
                    expected: { rows: 3, cols: 3 }
                },
                {
                    name: "Mixed tab and space (should use tab)",
                    input: `A\tB C\tD\n1\t2 3\t4\n5\t6 7\t8`,
                    expected: { rows: 2, cols: 3 }
                },
                {
                    name: "Comma decimals",
                    input: `A B C\n0,85 0,10 0,05\n0,15 0,80 0,05`,
                    expected: { rows: 2, cols: 3 }
                },
                {
                    name: "Empty trailing cells (tabs)",
                    input: `A\tB\tC\t\n1\t2\t3\t\n4\t5\t6\t`,
                    expected: { rows: 2, cols: 3 }
                },
                {
                    name: "Empty trailing cells (spaces)", 
                    input: `A B C \n1 2 3 \n4 5 6 `,
                    expected: { rows: 2, cols: 3 }
                }
            ];

            let passed = 0;
            let failed = 0;

            for (const test of tests) {
                try {
                    console.log(`Testing: ${test.name}`);
                    console.log(`Input: "${test.input}"`);
                    
                    const result = parseTableData(test.input);
                    const actual_rows = result.matrix_values.length;
                    const actual_cols = result.matrix_values[0].length;
                    
                    if (actual_rows === test.expected.rows && actual_cols === test.expected.cols) {
                        console.log(`‚úÖ PASS: ${test.name}`);
                        passed++;
                    } else {
                        console.log(`‚ùå FAIL: ${test.name} - Expected ${test.expected.rows}x${test.expected.cols}, got ${actual_rows}x${actual_cols}`);
                        failed++;
                    }
                    console.log(`Result:`, result);
                } catch (error) {
                    console.log(`‚ùå ERROR: ${test.name} - ${error.message}`);
                    failed++;
                }
                console.log('---');
            }

            console.log(`Tests completed: ${passed} passed, ${failed} failed`);
            return failed === 0;
        }

        /**
         * Parses CSV data into a structured format
         * Throws an error if the data is not valid CSV
         * @param {string} table_data - Raw CSV data (comma separated)
         * @returns {Object} Parsed data with headers and matrix values
         * @throws {Error} If data is not valid CSV format
         */
        function parseCSV(table_data) {
            const lines = table_data.trim().split('\n').filter(line => line.trim());
            
            if (lines.length < 2) {
                throw new Error('CSV must have at least a header row and one data row');
            }
            
            /**
             * Parses a CSV line handling quoted fields
             * @param {string} line - CSV line to parse
             * @returns {Array<string>} Array of cell values
             */
            function parseCSVLine(line) {
                const cells = [];
                let current_cell = '';
                let inside_quotes = false;
                
                for (let idx = 0; idx < line.length; idx++) {
                    const char = line[idx];
                    
                    if (char === '"') {
                        if (inside_quotes && idx + 1 < line.length && line[idx + 1] === '"') {
                            // Escaped quote
                            current_cell += '"';
                            idx++; // Skip next quote
                        } else {
                            // Toggle quote state
                            inside_quotes = !inside_quotes;
                        }
                    } else if (char === ',' && !inside_quotes) {
                        // End of cell
                        cells.push(current_cell.trim());
                        current_cell = '';
                    } else {
                        current_cell += char;
                    }
                }
                
                // Add last cell
                cells.push(current_cell.trim());
                
                return cells;
            }
            
            // Parse header row
            const header_row = parseCSVLine(lines[0]);
            
            // Validate CSV format: should have commas
            if (header_row.length < 2 && !lines[0].includes(',')) {
                throw new Error('Not valid CSV: no comma separators found');
            }
            
            // Column labels: skip first empty cell if present
            const column_labels = header_row[0] === '' ? header_row.slice(1) : header_row;
            
            // Parse data rows
            const data_rows = [];
            const row_labels = [];
            
            for (let row_index = 1; row_index < lines.length; row_index++) {
                const cells = parseCSVLine(lines[row_index]);
                
                // Expected length: header_row.length (which includes first cell, possibly empty)
                if (cells.length !== header_row.length) {
                    throw new Error(`CSV row ${row_index + 1} has ${cells.length} columns, expected ${header_row.length}`);
                }
                
                // First cell is row label
                let row_label = cells[0];
                if (row_label.startsWith('"') && row_label.endsWith('"')) {
                    row_label = row_label.slice(1, -1);
                }
                row_labels.push(row_label || `Row ${row_index}`);
                
                // Parse numeric values (skip first cell which is row label)
                const numeric_values = [];
                for (let col_index = 1; col_index < cells.length; col_index++) {
                    // Remove quotes if present
                    let cell_value = cells[col_index];
                    if (cell_value.startsWith('"') && cell_value.endsWith('"')) {
                        cell_value = cell_value.slice(1, -1);
                    }
                    
                    // Handle comma decimal separator (but preserve comma as separator)
                    const normalized_value = cell_value.replace(',', '.');
                    const parsed_value = parseFloat(normalized_value);
                    
                    if (isNaN(parsed_value)) {
                        throw new Error(`CSV: Invalid numeric value "${cells[col_index]}" at row ${row_index + 1}, column ${col_index + 1}`);
                    }
                    
                    numeric_values.push(parsed_value);
                }
                
                data_rows.push(numeric_values);
            }
            
            return {
                column_labels: column_labels,
                row_labels: row_labels,
                matrix_values: data_rows
            };
        }

        /**
         * Parses TSV (tab or space separated) data into a structured format
         * Throws an error if the data is not valid TSV
         * @param {string} table_data - Raw TSV data (tab or space separated)
         * @returns {Object} Parsed data with headers and matrix values
         * @throws {Error} If data is not valid TSV format
         */
        function parseTSV(table_data) {
            const lines = table_data.trim().split('\n').filter(line => line.trim());
            
            if (lines.length < 2) {
                throw new Error('TSV must have at least a header row and one data row');
            }
            
            // Smart separator detection: check each line individually
            function detectSeparator(line) {
                if (line.includes('\t')) {
                    return '\t';
                } else {
                    return /\s+/;
                }
            }
            
            function splitLine(line) {
                const separator = detectSeparator(line);
                return line.split(separator).map(cell => cell.trim()).filter(cell => cell.length > 0);
            }
            
            // Parse header row
            const header_row = splitLine(lines[0]);
            
            // Validate TSV format: should have tabs or multiple spaces, not commas
            if (lines[0].includes(',') && !lines[0].includes('\t') && !/\s{2,}/.test(lines[0])) {
                throw new Error('Not valid TSV: appears to be CSV format');
            }
            
            // Parse data rows
            const data_rows = [];
            const row_labels = [];
            
            for (let row_index = 1; row_index < lines.length; row_index++) {
                const cells = splitLine(lines[row_index]);
                
                if (cells.length !== header_row.length) {
                    throw new Error(`TSV row ${row_index + 1} has ${cells.length} columns, expected ${header_row.length}`);
                }
                
                const numeric_values = [];
                for (let col_index = 0; col_index < cells.length; col_index++) {
                    // Handle comma decimal separator
                    const normalized_value = cells[col_index].replace(',', '.');
                    const parsed_value = parseFloat(normalized_value);
                    
                    if (isNaN(parsed_value)) {
                        throw new Error(`TSV: Invalid numeric value "${cells[col_index]}" at row ${row_index + 1}, column ${col_index + 1}`);
                    }
                    
                    numeric_values.push(parsed_value);
                }
                
                data_rows.push(numeric_values);
                row_labels.push(header_row[row_index - 1] || `Row ${row_index}`);
            }
            
            return {
                column_labels: header_row,
                row_labels: row_labels,
                matrix_values: data_rows
            };
        }

        /**
         * Parses table data, automatically detecting CSV or TSV format
         * Tries CSV first, then TSV if CSV fails
         * @param {string} table_data - Raw table data (CSV or TSV)
         * @returns {Object} Parsed data with headers and matrix values
         * @throws {Error} If data cannot be parsed as either CSV or TSV
         */
        function parseTableData(table_data) {
            // Try CSV first
            try {
                return parseCSV(table_data);
            } catch (csv_error) {
                // If CSV fails, try TSV
                try {
                    return parseTSV(table_data);
                } catch (tsv_error) {
                    // Both failed, throw a combined error message
                    throw new Error(`Failed to parse as CSV: ${csv_error.message}. Failed to parse as TSV: ${tsv_error.message}`);
                }
            }
        }

        /**
         * Generates RGB color value for white-to-blue colormap
         * @param {number} normalized_value - Value between 0 and 1
         * @returns {string} RGB color string
         */
        function generateColorFromValue(normalized_value) {
            // Ensure value is between 0 and 1
            const clamped_value = Math.max(0, Math.min(1, normalized_value));
            
            // White to blue transition
            const red_component = Math.round(255 * (1 - clamped_value));
            const green_component = Math.round(255 * (1 - clamped_value));
            const blue_component = 255;
            
            return `rgb(${red_component}, ${green_component}, ${blue_component})`;
        }

        /**
         * Converts a digit character to its superscript Unicode equivalent
         * @param {string} char - Single character (digit or minus sign)
         * @returns {string} Superscript character
         */
        function toSuperscript(char) {
            const SUPERSCRIPT_MAP = {
                '0': '‚Å∞', '1': '¬π', '2': '¬≤', '3': '¬≥', '4': '‚Å¥',
                '5': '‚Åµ', '6': '‚Å∂', '7': '‚Å∑', '8': '‚Å∏', '9': '‚Åπ',
                '-': '‚Åª', '+': '‚Å∫'
            };
            return SUPERSCRIPT_MAP[char] || char;
        }

        /**
         * Formats a number for display in matrix cells with fancy scientific notation
         * Uses superscript characters for very small non-zero values (e.g., 5√ó10‚Åª‚Åµ‚Å∞)
         * @param {number} value - The number to format
         * @param {number} decimal_places - Number of decimal places for fixed notation
         * @returns {string} Formatted number string with fancy notation for small values
         */
        function formatNumberForDisplay(value, decimal_places) {
            assert(typeof value === 'number', `Expected number, got ${typeof value}`);
            assert(Number.isInteger(decimal_places) && decimal_places >= 0, 
                   `decimal_places must be non-negative integer, got ${decimal_places}`);
            
            // Exact zero - show just "0" for cleaner display
            if (value === 0) {
                return '0';
            }
            
            const fixed_string = value.toFixed(decimal_places);
            
            // Check if fixed notation would show as zero (all zeros after decimal point)
            const would_show_as_zero = parseFloat(fixed_string) === 0;
            
            if (!would_show_as_zero) {
                return fixed_string;
            }
            
            // Use scientific notation for very small non-zero values
            const exponential = value.toExponential(2);
            const match = exponential.match(/^(-?)(\d+\.?\d*)e([+-]?\d+)$/);
            
            if (!match) {
                return fixed_string;
            }
            
            const sign = match[1];
            const mantissa = parseFloat(match[2]);
            const exponent = match[3];
            
            // Convert exponent digits to superscript
            const superscript_exponent = exponent.split('').map(toSuperscript).join('');
            
            // Format mantissa to remove trailing zeros and unnecessary decimal point
            const formatted_mantissa = mantissa.toString();
            
            return `${sign}${formatted_mantissa}√ó10${superscript_exponent}`;
        }

        /**
         * Formats a number for copy-pasteable text output with e notation
         * Uses standard e notation for very small non-zero values (e.g., 5e-50)
         * @param {number} value - The number to format
         * @param {number} decimal_places - Number of decimal places for fixed notation
         * @returns {string} Formatted number string with e notation for small values
         */
        function formatNumberForText(value, decimal_places) {
            assert(typeof value === 'number', `Expected number, got ${typeof value}`);
            assert(Number.isInteger(decimal_places) && decimal_places >= 0, 
                   `decimal_places must be non-negative integer, got ${decimal_places}`);
            
            // Exact zero
            if (value === 0) {
                return value.toFixed(decimal_places);
            }
            
            const fixed_string = value.toFixed(decimal_places);
            
            // Check if fixed notation would show as zero (all zeros after decimal point)
            const would_show_as_zero = parseFloat(fixed_string) === 0;
            
            if (!would_show_as_zero) {
                return fixed_string;
            }
            
            // Use e notation for very small non-zero values
            return value.toExponential(2);
        }

        /**
         * Normalizes matrix rows so each row sums to 1
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<Array<number>>} Row-normalized matrix
         */
        function normalizeByRows(matrix_values) {
            return matrix_values.map(row => {
                const row_sum = row.reduce((sum, value) => sum + value, 0);
                if (row_sum === 0) {
                    return row.map(() => 0);
                }
                return row.map(value => value / row_sum);
            });
        }

        /**
         * Normalizes matrix columns so each column sums to 1
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<Array<number>>} Column-normalized matrix
         */
        function normalizeByColumns(matrix_values) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            // Calculate column sums
            const column_sums = new Array(num_cols).fill(0);
            for (let row_index = 0; row_index < num_rows; row_index++) {
                for (let col_index = 0; col_index < num_cols; col_index++) {
                    column_sums[col_index] += matrix_values[row_index][col_index];
                }
            }
            
            // Normalize each element by its column sum
            const normalized_matrix = [];
            for (let row_index = 0; row_index < num_rows; row_index++) {
                const normalized_row = [];
                for (let col_index = 0; col_index < num_cols; col_index++) {
                    if (column_sums[col_index] === 0) {
                        normalized_row.push(0);
                    } else {
                        normalized_row.push(matrix_values[row_index][col_index] / column_sums[col_index]);
                    }
                }
                normalized_matrix.push(normalized_row);
            }
            
            return normalized_matrix;
        }

        /**
         * Normalizes matrix by rows first, then by columns
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<Array<number>>} Row-then-column normalized matrix
         */
        function normalizeRowThenColumn(matrix_values) {
            const row_normalized = normalizeByRows(matrix_values);
            return normalizeByColumns(row_normalized);
        }

        /**
         * Normalizes matrix by rows (truth), then multiplies each row by corresponding prior frequency
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values, shape (n_rows, n_cols)
         * @param {Array<number>} prior_frequencies - Prior frequencies for each row (will be normalized to sum to 1)
         * @returns {Array<Array<number>>} Prior-normalized matrix
         */
        function normalizeByPrior(matrix_values, prior_frequencies) {
            assert(Array.isArray(matrix_values), `Expected array, got ${typeof matrix_values}`);
            assert(Array.isArray(prior_frequencies), `Expected array, got ${typeof prior_frequencies}`);
            assert(matrix_values.length === prior_frequencies.length, 
                   `Matrix rows (${matrix_values.length}) must match prior frequencies length (${prior_frequencies.length})`);
            
            // Normalize prior frequencies to sum to 1.0
            const sum_prior = prior_frequencies.reduce((s, p) => s + p, 0);
            assert(sum_prior > 0, 'Prior frequencies sum must be positive');
            const normalized_priors = prior_frequencies.map(p => p / sum_prior);
            
            // First normalize by rows (truth normalization)
            const row_normalized = normalizeByRows(matrix_values);
            
            // Then multiply each row by its prior frequency
            return row_normalized.map((row, row_idx) => 
                row.map(val => val * normalized_priors[row_idx])
            );
        }

        /**
         * Normalizes matrix by rows (truth), multiplies by prior frequencies, then normalizes by columns (prediction)
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values, shape (n_rows, n_cols)
         * @param {Array<number>} prior_frequencies - Prior frequencies for each row (will be normalized to sum to 1)
         * @returns {Array<Array<number>>} Prior-then-column normalized matrix
         */
        function normalizePriorThenColumn(matrix_values, prior_frequencies) {
            assert(Array.isArray(matrix_values), `Expected array, got ${typeof matrix_values}`);
            assert(Array.isArray(prior_frequencies), `Expected array, got ${typeof prior_frequencies}`);
            assert(matrix_values.length === prior_frequencies.length, 
                   `Matrix rows (${matrix_values.length}) must match prior frequencies length (${prior_frequencies.length})`);
            
            // Normalize prior frequencies to sum to 1.0
            const sum_prior = prior_frequencies.reduce((s, p) => s + p, 0);
            assert(sum_prior > 0, 'Prior frequencies sum must be positive');
            const normalized_priors = prior_frequencies.map(p => p / sum_prior);
            
            // First normalize by rows (truth normalization)
            const row_normalized = normalizeByRows(matrix_values);
            
            // Multiply each row by its prior frequency
            const prior_normalized = row_normalized.map((row, row_idx) => 
                row.map(val => val * normalized_priors[row_idx])
            );
            
            // Then normalize by columns (prediction normalization)
            return normalizeByColumns(prior_normalized);
        }

        /**
         * Applies Sinkhorn-Knopp normalization algorithm with RAS decomposition
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @param {number} max_iterations - Maximum number of iterations (default: 100)
         * @param {number} tolerance - Convergence tolerance (default: 1e-6)
         * @param {boolean} return_decomposition - Whether to return decomposition info
         * @returns {Array<Array<number>>|Object} Sinkhorn-Knopp normalized matrix or decomposition object
         */
        function normalizeSinkhornKnopp(matrix_values, max_iterations = 100, tolerance = 1e-6, return_decomposition = false) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            // Create a copy of the matrix
            let current_matrix = matrix_values.map(row => [...row]);
            
            // Check if matrix has any non-zero elements
            const total_sum = current_matrix.flat().reduce((sum, val) => sum + val, 0);
            if (total_sum === 0) {
                if (return_decomposition) {
                    return {
                        matrix: current_matrix,
                        row_scaling: new Array(num_rows).fill(1),
                        column_scaling: new Array(num_cols).fill(1),
                        doubly_stochastic: current_matrix.map(row => [...row])
                    };
                }
                return current_matrix;
            }
            
            // Initialize scaling factors for RAS decomposition
            let row_scaling = new Array(num_rows).fill(1);
            let column_scaling = new Array(num_cols).fill(1);
            
            for (let iteration = 0; iteration < max_iterations; iteration++) {
                // Store previous matrix for convergence check
                const previous_matrix = current_matrix.map(row => [...row]);
                
                // Row scaling step
                for (let row_index = 0; row_index < num_rows; row_index++) {
                    const row_sum = current_matrix[row_index].reduce((sum, val) => sum + val, 0);
                    if (row_sum > 0) {
                        const row_factor = 1 / row_sum;
                        row_scaling[row_index] *= row_factor;
                        for (let col_index = 0; col_index < num_cols; col_index++) {
                            current_matrix[row_index][col_index] *= row_factor;
                        }
                    }
                }
                
                // Column scaling step
                for (let col_index = 0; col_index < num_cols; col_index++) {
                    let col_sum = 0;
                    for (let row_index = 0; row_index < num_rows; row_index++) {
                        col_sum += current_matrix[row_index][col_index];
                    }
                    if (col_sum > 0) {
                        const col_factor = 1 / col_sum;
                        column_scaling[col_index] *= col_factor;
                        for (let row_index = 0; row_index < num_rows; row_index++) {
                            current_matrix[row_index][col_index] *= col_factor;
                        }
                    }
                }
                
                // Check for convergence
                let max_difference = 0;
                for (let row_index = 0; row_index < num_rows; row_index++) {
                    for (let col_index = 0; col_index < num_cols; col_index++) {
                        const difference = Math.abs(current_matrix[row_index][col_index] - previous_matrix[row_index][col_index]);
                        max_difference = Math.max(max_difference, difference);
                    }
                }
                
                if (max_difference < tolerance) {
                    break;
                }
            }
            
            if (return_decomposition) {
                return {
                    matrix: current_matrix,
                    row_scaling: row_scaling,
                    column_scaling: column_scaling,
                    doubly_stochastic: current_matrix.map(row => [...row])
                };
            }
            
            return current_matrix;
        }

        /**
         * Applies additive smoothing (Laplace smoothing) to matrix values
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @param {number} alpha - Smoothing parameter (pseudocount)
         * @returns {Array<Array<number>>} Smoothed matrix with alpha added to each cell
         */
        function applyAdditiveSmoothing(matrix_values, alpha = 0.5) {
            return matrix_values.map(row => 
                row.map(val => val + alpha)
            );
        }

        /**
         * Applies hierarchical prior-aware smoothing to matrix values
         * Pseudocount for cell [i,j] = k √ó prior_œÄ_i √ó prediction_œÄ_j
         * This represents a prior belief that the classifier is noninformative (independent)
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values, shape (n_rows, n_cols)
         * @param {number} k - Total pseudocount mass (default 0.5)
         * @param {number} alpha_marginal - Smoothing for marginal estimation (default 0.5)
         * @returns {Array<Array<number>>} Smoothed matrix with structured pseudocounts
         */
        function applyHierarchicalSmoothing(matrix_values, k = 0.5, alpha_prior = 0.5, alpha_prediction = 0.5) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            // Calculate row sums (prior/truth marginals)
            const row_sums = matrix_values.map(row => row.reduce((sum, val) => sum + val, 0));
            const total_sum = row_sums.reduce((sum, val) => sum + val, 0);
            
            // Calculate column sums (prediction marginals)
            const col_sums = new Array(num_cols).fill(0);
            for (let col_idx = 0; col_idx < num_cols; col_idx++) {
                for (let row_idx = 0; row_idx < num_rows; row_idx++) {
                    col_sums[col_idx] += matrix_values[row_idx][col_idx];
                }
            }
            
            // Estimate marginal probabilities with separate smoothing for each marginal
            const prior_pi = row_sums.map(sum => (sum + alpha_prior) / (total_sum + num_rows * alpha_prior));
            const prediction_pi = col_sums.map(sum => (sum + alpha_prediction) / (total_sum + num_cols * alpha_prediction));
            
            // Apply hierarchical pseudocounts: pseudocount[i,j] = k √ó prior_œÄ_i √ó prediction_œÄ_j
            return matrix_values.map((row, row_idx) => 
                row.map((val, col_idx) => val + k * prior_pi[row_idx] * prediction_pi[col_idx])
            );
        }

        /**
         * Normalizes matrix by dividing all elements by the total sum
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<Array<number>>} Sum-normalized matrix (joint probability distribution)
         */
        function normalizeBySum(matrix_values) {
            const total_sum = matrix_values.flat().reduce((sum, val) => sum + val, 0);
            
            if (total_sum === 0) {
                return matrix_values.map(row => [...row]); // Return copy of zero matrix
            }
            
            return matrix_values.map(row => 
                row.map(val => val / total_sum)
            );
        }

        /**
         * Applies the selected normalization to matrix values with optional preprocessing
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} use_smoothing - Whether to apply additive smoothing
         * @param {number} alpha - Smoothing parameter (if smoothing enabled)
         * @returns {Array<Array<number>>} Normalized matrix
         */
        function applyNormalization(matrix_values, normalization_type, use_smoothing = false, alpha = 0.5, smoothing_type = 'uniform', k_value = 0.5, alpha_prior = 0.5, alpha_prediction = 0.5, row_labels = null) {
            // Apply smoothing preprocessing if enabled
            let processed_matrix = matrix_values;
            if (use_smoothing) {
                if (smoothing_type === 'hierarchical') {
                    processed_matrix = applyHierarchicalSmoothing(matrix_values, k_value, alpha_prior, alpha_prediction);
                } else {
                processed_matrix = applyAdditiveSmoothing(matrix_values, alpha);
                }
            }
            
            switch (normalization_type) {
                case 'row':
                    return normalizeByRows(processed_matrix);
                case 'column':
                    return normalizeByColumns(processed_matrix);
                case 'row_then_column':
                    return normalizeRowThenColumn(processed_matrix);
                case 'sinkhorn_knopp':
                    return normalizeSinkhornKnopp(processed_matrix);
                case 'sum':
                    return normalizeBySum(processed_matrix);
                case 'prior':
                    if (!row_labels) {
                        throw new Error('Row labels required for prior normalization');
                    }
                    const prior_input = document.getElementById('prior-frequencies-input').value;
                    try {
                        const prior_frequencies = parsePriorFrequencies(prior_input, row_labels);
                        clearPriorFrequenciesError();
                        return normalizeByPrior(processed_matrix, prior_frequencies);
                    } catch (parse_error) {
                        showPriorFrequenciesError(parse_error.message);
                        throw parse_error;
                    }
                case 'prior_then_column':
                    if (!row_labels) {
                        throw new Error('Row labels required for prior normalization');
                    }
                    const prior_input_then = document.getElementById('prior-frequencies-input').value;
                    try {
                        const prior_frequencies_then = parsePriorFrequencies(prior_input_then, row_labels);
                        clearPriorFrequenciesError();
                        return normalizePriorThenColumn(processed_matrix, prior_frequencies_then);
                    } catch (parse_error) {
                        showPriorFrequenciesError(parse_error.message);
                        throw parse_error;
                    }
                case 'none':
                default:
                    return processed_matrix;
            }
        }

        /**
         * Calculates color intensity based on matrix values
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<Array<number>>} Normalized values for color mapping
         */
        function calculateColorIntensities(matrix_values) {
            // Find min and max values across entire matrix
            let min_value = Infinity;
            let max_value = -Infinity;
            
            for (const row_values of matrix_values) {
                for (const cell_value of row_values) {
                    min_value = Math.min(min_value, cell_value);
                    max_value = Math.max(max_value, cell_value);
                }
            }
            
            // Handle edge case where all values are the same
            const value_range = max_value - min_value;
            if (value_range === 0) {
                return matrix_values.map(row => row.map(() => 0.5));
            }
            
            // Normalize values to 0-1 range
            return matrix_values.map(row => 
                row.map(value => (value - min_value) / value_range)
            );
        }

        /**
         * Renders the confusion matrix as an HTML table
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} include_sums - Whether to include row/column sums
         * @param {boolean} include_info - Whether to include answer information row
         * side-effects: Modifies DOM element with id 'matrix-container'
         */
        function renderConfusionMatrix(parsed_data, normalization_type = 'none', include_sums = true, include_info = true, use_smoothing = false, alpha = 0.5, smoothing_type = 'uniform', k_value = 0.5, alpha_prior = 0.5, alpha_prediction = 0.5) {
            const matrix_container = document.getElementById('matrix-container');
            const normalized_matrix = applyNormalization(parsed_data.matrix_values, normalization_type, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction, parsed_data.row_labels);
            const normalized_intensities = calculateColorIntensities(normalized_matrix);
            
            // Calculate row sums, column sums, and total sum
            const row_sums = normalized_matrix.map(row => row.reduce((sum, val) => sum + val, 0));
            const column_sums = [];
            for (let col_index = 0; col_index < normalized_matrix[0].length; col_index++) {
                let col_sum = 0;
                for (let row_index = 0; row_index < normalized_matrix.length; row_index++) {
                    col_sum += normalized_matrix[row_index][col_index];
                }
                column_sums.push(col_sum);
            }
            const total_sum = row_sums.reduce((sum, val) => sum + val, 0);
            
            // Calculate answer information if needed
            let answer_information = [];
            if (include_info) {
                answer_information = calculateClassifierAnswerInformation(normalized_matrix);
            }
            
            // Create table element
            const table_element = document.createElement('table');
            table_element.className = 'confusion-matrix';
            
            // Create header row
            const header_row = document.createElement('tr');
            
            // Corner cell
            const corner_cell = document.createElement('th');
            corner_cell.className = 'corner';
            try {
                corner_cell.textContent = `${t('predictedLabel')}\n${t('actualLabel')}`;
            } catch (_) {
                corner_cell.textContent = 'Predicted ‚Üí\nActual ‚Üì';
            }
            corner_cell.style.whiteSpace = 'pre-line';
            header_row.appendChild(corner_cell);
            
            // Column headers
            for (const column_label of parsed_data.column_labels) {
                const header_cell = document.createElement('th');
                header_cell.textContent = column_label;
                header_row.appendChild(header_cell);
            }
            
            // Sum column header
            if (include_sums) {
                const sum_header_cell = document.createElement('th');
                sum_header_cell.textContent = t('sumLabel');
                sum_header_cell.style.backgroundColor = '#e9ecef';
                sum_header_cell.style.fontWeight = 'bold';
                header_row.appendChild(sum_header_cell);
            }
            
            table_element.appendChild(header_row);
            
            // Create data rows
            for (let row_index = 0; row_index < parsed_data.matrix_values.length; row_index++) {
                const data_row = document.createElement('tr');
                
                // Row header
                const row_header_cell = document.createElement('th');
                row_header_cell.className = 'row-header';
                row_header_cell.textContent = parsed_data.row_labels[row_index];
                data_row.appendChild(row_header_cell);
                
                // Data cells
                for (let col_index = 0; col_index < normalized_matrix[row_index].length; col_index++) {
                    const data_cell = document.createElement('td');
                    const cell_value = normalized_matrix[row_index][col_index];
                    const color_intensity = normalized_intensities[row_index][col_index];
                    
                    data_cell.textContent = formatNumberForDisplay(cell_value, 4);
                    data_cell.style.backgroundColor = generateColorFromValue(color_intensity);
                    
                    // Add white text for dark cells
                    if (color_intensity > 0.6) {
                        data_cell.style.color = 'white';
                    }
                    
                    data_row.appendChild(data_cell);
                }
                
                // Row sum cell
                if (include_sums) {
                    const row_sum_cell = document.createElement('td');
                    row_sum_cell.textContent = formatNumberForDisplay(row_sums[row_index], 4);
                    row_sum_cell.style.backgroundColor = '#f8f9fa';
                    row_sum_cell.style.fontWeight = 'bold';
                    row_sum_cell.style.borderLeft = '2px solid #dee2e6';
                    data_row.appendChild(row_sum_cell);
                }
                
                table_element.appendChild(data_row);
            }
            
            // Add column sum row
            if (include_sums) {
                const sum_row = document.createElement('tr');
                
                // Sum row header
                const sum_row_header = document.createElement('th');
                sum_row_header.className = 'row-header';
                sum_row_header.textContent = t('sumLabel');
                sum_row_header.style.backgroundColor = '#e9ecef';
                sum_row_header.style.fontWeight = 'bold';
                sum_row_header.style.borderTop = '2px solid #dee2e6';
                sum_row.appendChild(sum_row_header);
                
                // Column sum cells
                for (let col_index = 0; col_index < column_sums.length; col_index++) {
                    const col_sum_cell = document.createElement('td');
                    col_sum_cell.textContent = formatNumberForDisplay(column_sums[col_index], 4);
                    col_sum_cell.style.backgroundColor = '#f8f9fa';
                    col_sum_cell.style.fontWeight = 'bold';
                    col_sum_cell.style.borderTop = '2px solid #dee2e6';
                    sum_row.appendChild(col_sum_cell);
                }
                
                // Total sum cell (intersection of Sum row and Sum column)
                const total_sum_cell = document.createElement('td');
                total_sum_cell.textContent = formatNumberForDisplay(total_sum, 4);
                total_sum_cell.style.backgroundColor = '#e9ecef';
                total_sum_cell.style.fontWeight = 'bold';
                total_sum_cell.style.borderTop = '2px solid #dee2e6';
                total_sum_cell.style.borderLeft = '2px solid #dee2e6';
                sum_row.appendChild(total_sum_cell);
                
                table_element.appendChild(sum_row);
            }
            
            // Add answer information row
            if (include_info) {
                const info_row = document.createElement('tr');
                
                // Info row header
                const info_row_header = document.createElement('th');
                info_row_header.className = 'row-header';
                // Compute theoretical maximum info per answer: max_Q D_KL(Q || P(true)) = log2(1 / min P(true))
                let max_info_bits = 0;
                if (total_sum > 0) {
                    const row_marginals_for_max = row_sums.map(function(sum_val) { return sum_val / total_sum; });
                    const positive_priors = row_marginals_for_max.filter(function(p) { return p > 0; });
                    if (positive_priors.length > 0) {
                        const min_prior = Math.min.apply(null, positive_priors);
                        max_info_bits = (min_prior > 0) ? Math.log2(1 / min_prior) : Infinity;
                    } else {
                        max_info_bits = 0;
                    }
                }
                const is_finite_max = Number.isFinite(max_info_bits);
                const max_suffix = (function() {
                    const maxShort = t('tooltips.maxShortPrefix');
                    const bitsWord = t('tooltips.bitsWord');
                    return is_finite_max ? '(' + maxShort + ' ' + max_info_bits.toFixed(3) + ' ' + bitsWord + ')' : '(' + maxShort + ' ‚àû)';
                })();
                // Split into two lines for readability
                info_row_header.innerHTML = t('answerInfoLabel') + '<br>' + max_suffix;
                const tooltip_with_max = (function() {
                    const base = t('tooltips.answerInfo') + '\n\n' + t('tooltips.answerInfoMethod') + '\n\n' + t('tooltips.answerInfoMaxMethod');
                    const maxPrefix = t('tooltips.answerInfoMaxPrefix');
                    const bitsWord = t('tooltips.bitsWord');
                    return base + (is_finite_max ? '\n' + maxPrefix + max_info_bits.toFixed(3) + ' ' + bitsWord : '\n' + maxPrefix + '‚àû');
                })();
                info_row_header.setAttribute('data-tooltip', tooltip_with_max);
                info_row_header.style.backgroundColor = '#e3f2fd';
                info_row_header.style.fontWeight = 'bold';
                info_row_header.style.borderTop = '2px solid #90caf9';
                info_row_header.style.color = '#1565c0';
                info_row.appendChild(info_row_header);

                // Attach custom tooltip handlers to match existing style
                info_row_header.addEventListener('mouseenter', function(event) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'custom-tooltip';
                    tooltip.textContent = this.getAttribute('data-tooltip');
                    Object.assign(tooltip.style, {
                        position: 'fixed',
                        background: '#333',
                        color: 'white',
                        padding: '16px 20px',
                        borderRadius: '8px',
                        fontSize: '14px',
                        lineHeight: '1.5',
                        whiteSpace: 'pre-line',
                        zIndex: '9999',
                        opacity: '0.95',
                        maxWidth: '400px',
                        textAlign: 'left',
                        boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                        pointerEvents: 'none',
                        fontFamily: 'system-ui, -apple-system, sans-serif'
                    });
                    const rect = this.getBoundingClientRect();
                    tooltip.style.left = (rect.left + rect.width / 2) + 'px';
                    tooltip.style.top = (rect.top - 10) + 'px';
                    tooltip.style.transform = 'translateX(-50%) translateY(-100%)';
                    document.body.appendChild(tooltip);
                });
                info_row_header.addEventListener('mouseleave', function() {
                    const tooltips = document.querySelectorAll('.custom-tooltip');
                    tooltips.forEach(tooltip => tooltip.remove());
                });
                
                // Answer information cells
                for (let col_index = 0; col_index < answer_information.length; col_index++) {
                    const info_cell = document.createElement('td');
                    info_cell.textContent = formatNumberForDisplay(answer_information[col_index], 3);
                    info_cell.style.backgroundColor = '#f3e5f5';
                    info_cell.style.fontWeight = 'bold';
                    info_cell.style.borderTop = '2px solid #90caf9';
                    info_cell.style.color = '#4a148c';
                    info_row.appendChild(info_cell);
                }
                
                // Empty cell for sum column if sums are included
                if (include_sums) {
                    const empty_cell = document.createElement('td');
                    empty_cell.style.backgroundColor = '#f3e5f5';
                    empty_cell.style.borderTop = '2px solid #90caf9';
                    empty_cell.style.borderLeft = '2px solid #dee2e6';
                    info_row.appendChild(empty_cell);
                }
                
                table_element.appendChild(info_row);
            }
            
            matrix_container.innerHTML = '';
            matrix_container.appendChild(table_element);
        }

        /**
         * Generates tab-separated text representation of the matrix
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} include_sums - Whether to include row/column sums
         * @param {boolean} include_info - Whether to include answer information row
         * @param {boolean} use_smoothing - Whether to apply additive smoothing
         * @param {number} alpha - Smoothing parameter (if smoothing enabled)
         * @returns {string} Tab-separated text representation
         */
        function generateTabSeparatedText(parsed_data, normalization_type = 'none', include_sums = true, include_info = true, use_smoothing = false, alpha = 0.5, smoothing_type = 'uniform', k_value = 0.5, alpha_prior = 0.5, alpha_prediction = 0.5) {
            const normalized_matrix = applyNormalization(parsed_data.matrix_values, normalization_type, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction, parsed_data.row_labels);
            
            // Get decomposition for Sinkhorn-Knopp
            let decomposition = null;
            if (normalization_type === 'sinkhorn_knopp') {
                decomposition = normalizeSinkhornKnopp(parsed_data.matrix_values, 100, 1e-6, true);
            }
            
            // Calculate sums if needed
            let row_sums = [];
            let column_sums = [];
            let total_sum = 0;
            
            if (include_sums) {
                row_sums = normalized_matrix.map(row => row.reduce((sum, val) => sum + val, 0));
                column_sums = [];
                for (let col_index = 0; col_index < normalized_matrix[0].length; col_index++) {
                    let col_sum = 0;
                    for (let row_index = 0; row_index < normalized_matrix.length; row_index++) {
                        col_sum += normalized_matrix[row_index][col_index];
                    }
                    column_sums.push(col_sum);
                }
                total_sum = row_sums.reduce((sum, val) => sum + val, 0);
            }
            
            let text_content = '';
            
            // Header row
            text_content += '\t' + parsed_data.column_labels.join('\t');
            if (include_sums) {
                text_content += '\tSum';
            }
            if (decomposition) {
                text_content += '\tRow Scaling (r)';
            }
            text_content += '\n';
            
            // Data rows
            for (let row_index = 0; row_index < normalized_matrix.length; row_index++) {
                text_content += parsed_data.row_labels[row_index] + '\t';
                text_content += normalized_matrix[row_index].map(val => formatNumberForText(val, 4)).join('\t');
                if (include_sums) {
                    text_content += '\t' + formatNumberForText(row_sums[row_index], 4);
                }
                if (decomposition) {
                    text_content += '\t' + decomposition.row_scaling[row_index].toFixed(6);
                }
                text_content += '\n';
            }
            
            // Sum row
            if (include_sums) {
                text_content += 'Sum\t';
                text_content += column_sums.map(val => formatNumberForText(val, 4)).join('\t');
                text_content += '\t' + formatNumberForText(total_sum, 4);
                if (decomposition) {
                    text_content += '\t';  // Empty cell for row scaling column
                }
                text_content += '\n';
            }
            
            // Column scaling row for Sinkhorn-Knopp
            if (decomposition) {
                text_content += 'Column Scaling (c)\t';
                text_content += decomposition.column_scaling.map(val => val.toFixed(6)).join('\t');
                if (include_sums) {
                    text_content += '\t';  // Empty cell for sum column
                }
                text_content += '\t';  // Empty cell for row scaling column
                text_content += '\n';
                
                // Add reconstruction formula
                text_content += '\n';
                text_content += '# ' + t('tooltips.rasTooltip') + '\n';
                text_content += '# ' + t('tooltips.reconstructionTooltip') + '\n';
                text_content += '# ' + t('tooltips.rowScalingFactors') + ' and ' + t('tooltips.columnScalingFactors') + ' are included above\n';
            }
            
            // Answer information row
            if (include_info) {
                const answer_information = calculateClassifierAnswerInformation(normalized_matrix);
                text_content += t('answerInfoLabel') + '\t';
                text_content += answer_information.map(val => formatNumberForText(val, 3)).join('\t');
                if (include_sums) {
                    text_content += '\t';  // Empty cell for sum column
                }
                if (decomposition) {
                    text_content += '\t';  // Empty cell for row scaling column
                }
                text_content += '\n';
            }
            
            return text_content;
        }

        /**
         * Generates CSV representation of the matrix
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} include_sums - Whether to include row/column sums
         * @param {boolean} include_info - Whether to include answer information row
         * @param {boolean} use_smoothing - Whether to apply additive smoothing
         * @param {number} alpha - Smoothing parameter (if smoothing enabled)
         * @returns {string} CSV representation
         */
        function generateCSV(parsed_data, normalization_type = 'none', include_sums = true, include_info = true, use_smoothing = false, alpha = 0.5, smoothing_type = 'uniform', k_value = 0.5, alpha_prior = 0.5, alpha_prediction = 0.5) {
            const normalized_matrix = applyNormalization(parsed_data.matrix_values, normalization_type, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction, parsed_data.row_labels);
            
            // Get decomposition for Sinkhorn-Knopp
            let decomposition = null;
            if (normalization_type === 'sinkhorn_knopp') {
                decomposition = normalizeSinkhornKnopp(parsed_data.matrix_values, 100, 1e-6, true);
            }
            
            // Calculate sums if needed
            let row_sums = [];
            let column_sums = [];
            let total_sum = 0;
            
            if (include_sums) {
                row_sums = normalized_matrix.map(row => row.reduce((sum, val) => sum + val, 0));
                column_sums = [];
                for (let col_index = 0; col_index < normalized_matrix[0].length; col_index++) {
                    let col_sum = 0;
                    for (let row_index = 0; row_index < normalized_matrix.length; row_index++) {
                        col_sum += normalized_matrix[row_index][col_index];
                    }
                    column_sums.push(col_sum);
                }
                total_sum = row_sums.reduce((sum, val) => sum + val, 0);
            }
            
            let csv_content = '';
            
            // Header row
            csv_content += ',' + parsed_data.column_labels.map(label => `"${label}"`).join(',');
            if (include_sums) {
                csv_content += ',"' + t('sumLabel') + '"';
            }
            if (decomposition) {
                csv_content += ',"Row Scaling (r)"';
            }
            csv_content += '\n';
            
            // Data rows
            for (let row_index = 0; row_index < normalized_matrix.length; row_index++) {
                csv_content += `"${parsed_data.row_labels[row_index]}",`;
                csv_content += normalized_matrix[row_index].map(val => formatNumberForText(val, 4)).join(',');
                if (include_sums) {
                    csv_content += ',' + formatNumberForText(row_sums[row_index], 4);
                }
                if (decomposition) {
                    csv_content += ',' + decomposition.row_scaling[row_index].toFixed(6);
                }
                csv_content += '\n';
            }
            
            // Sum row
            if (include_sums) {
                csv_content += '"' + t('sumLabel') + '",';
                csv_content += column_sums.map(val => formatNumberForText(val, 4)).join(',');
                csv_content += ',' + formatNumberForText(total_sum, 4);
                if (decomposition) {
                    csv_content += ',';  // Empty cell for row scaling column
                }
                csv_content += '\n';
            }
            
            // Column scaling row for Sinkhorn-Knopp
            if (decomposition) {
                csv_content += '"Column Scaling (c)",';
                csv_content += decomposition.column_scaling.map(val => val.toFixed(6)).join(',');
                if (include_sums) {
                    csv_content += ',';  // Empty cell for sum column
                }
                csv_content += ',';  // Empty cell for row scaling column
                csv_content += '\n';
                
                // Add reconstruction formula as comment
                csv_content += '\n';
                csv_content += '"# ' + t('tooltips.rasTooltip') + '"\n';
                csv_content += '"# ' + t('tooltips.reconstructionTooltip') + '"\n';
                csv_content += '"# ' + t('tooltips.rowScalingFactors') + ' and ' + t('tooltips.columnScalingFactors') + ' are included above"\n';
            }
            
            // Answer information row
            if (include_info) {
                const answer_information = calculateClassifierAnswerInformation(normalized_matrix);
                csv_content += '"' + t('answerInfoLabel') + '",';
                csv_content += answer_information.map(val => formatNumberForText(val, 3)).join(',');
                if (include_sums) {
                    csv_content += ',';  // Empty cell for sum column
                }
                if (decomposition) {
                    csv_content += ',';  // Empty cell for row scaling column
                }
                csv_content += '\n';
            }
            
            return csv_content;
        }

        /**
         * Renders the tab-separated text view
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} include_sums - Whether to include row/column sums
         * @param {boolean} include_info - Whether to include answer information row
         * @param {boolean} use_smoothing - Whether to apply additive smoothing
         * @param {number} alpha - Smoothing parameter (if smoothing enabled)
         * side-effects: Modifies DOM element with id 'text-view-container'
         */
        function renderTextView(parsed_data, normalization_type = 'none', include_sums = true, include_info = true, use_smoothing = false, alpha = 0.5, smoothing_type = 'uniform', k_value = 0.5, alpha_prior = 0.5, alpha_prediction = 0.5) {
            const text_container = document.getElementById('text-view-container');
            const text_content = generateTabSeparatedText(parsed_data, normalization_type, include_sums, include_info, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction);
            
            text_container.innerHTML = `
                <div class="text-view-content">${text_content}</div>
                <button class="copy-text-btn" onclick="copyTextToClipboard()">Copy to Clipboard</button>
            `;
        }

        /**
         * Downloads matrix as CSV file
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization to apply
         * @param {boolean} include_sums - Whether to include row/column sums
         * @param {boolean} include_info - Whether to include answer information row
         * @param {boolean} use_smoothing - Whether to apply additive smoothing
         * @param {number} alpha - Smoothing parameter (if smoothing enabled)
         * side-effects: Triggers file download
         */
        function downloadAsCSV(parsed_data, normalization_type = 'none', include_sums = true, include_info = true, use_smoothing = false, alpha = 0.5, smoothing_type = 'uniform', k_value = 0.5, alpha_prior = 0.5, alpha_prediction = 0.5) {
            const csv_content = generateCSV(parsed_data, normalization_type, include_sums, include_info, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction);
            
            const normalization_suffix = normalization_type === 'none' ? '' : `_${normalization_type}`;
            const filename = `confusion_matrix${normalization_suffix}.csv`;
            
            const blob = new Blob([csv_content], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        /**
         * Copies text view content to clipboard
         * side-effects: Copies text to clipboard, shows temporary feedback
         */
        function copyTextToClipboard() {
            const text_content = document.querySelector('.text-view-content').textContent;
            navigator.clipboard.writeText(text_content).then(() => {
                const copy_button = document.querySelector('.copy-text-btn');
                const original_text = copy_button.textContent;
                copy_button.textContent = 'Copied!';
                copy_button.style.backgroundColor = '#28a745';
                
                setTimeout(() => {
                    copy_button.textContent = original_text;
                    copy_button.style.backgroundColor = '#6c757d';
                }, 2000);
            }).catch(() => {
                alert('Failed to copy text to clipboard');
            });
        }

        /**
         * Calculates the trace of a square matrix (sum of diagonal elements)
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {number} Trace of the matrix
         */
        function calculateTrace(matrix_values) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            const min_dimension = Math.min(num_rows, num_cols);
            
            let trace_sum = 0;
            for (let index = 0; index < min_dimension; index++) {
                trace_sum += matrix_values[index][index];
            }
            
            return trace_sum;
        }

        /**
         * Calculates mutual information for confusion matrix
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values (must be probabilities/normalized)
         * @returns {number} Mutual information value
         */
        function calculateMutualInformation(matrix_values) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            // Calculate total sum to ensure matrix is normalized
            const total_sum = matrix_values.flat().reduce((sum, val) => sum + val, 0);
            
            // If matrix is not normalized, normalize it for MI calculation
            let normalized_matrix = matrix_values;
            if (Math.abs(total_sum - 1.0) > 1e-10) {
                if (total_sum === 0) {
                    return 0; // Cannot calculate MI for zero matrix
                }
                normalized_matrix = matrix_values.map(row => 
                    row.map(val => val / total_sum)
                );
            }
            
            // Calculate marginal probabilities
            const row_marginals = normalized_matrix.map(row => 
                row.reduce((sum, val) => sum + val, 0)
            );
            
            const column_marginals = [];
            for (let col_index = 0; col_index < num_cols; col_index++) {
                let col_sum = 0;
                for (let row_index = 0; row_index < num_rows; row_index++) {
                    col_sum += normalized_matrix[row_index][col_index];
                }
                column_marginals.push(col_sum);
            }
            
            // Calculate mutual information
            let mutual_information = 0;
            for (let row_index = 0; row_index < num_rows; row_index++) {
                for (let col_index = 0; col_index < num_cols; col_index++) {
                    const joint_prob = normalized_matrix[row_index][col_index];
                    const row_marginal = row_marginals[row_index];
                    const col_marginal = column_marginals[col_index];
                    
                    // Only add to MI if joint probability is non-zero
                    if (joint_prob > 0 && row_marginal > 0 && col_marginal > 0) {
                        const independent_prob = row_marginal * col_marginal;
                        mutual_information += joint_prob * Math.log2(joint_prob / independent_prob);
                    }
                }
            }
            
            return mutual_information;
        }

        /**
         * Calculates normalized mutual information (NMI)
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {number} Normalized mutual information value (0-1 range)
         */
        function calculateNormalizedMutualInformation(matrix_values) {
            const mutual_info = calculateMutualInformation(matrix_values);
            
            // Calculate entropy for normalization
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            const total_sum = matrix_values.flat().reduce((sum, val) => sum + val, 0);
            if (total_sum === 0) {
                return 0;
            }
            
            let normalized_matrix = matrix_values;
            if (Math.abs(total_sum - 1.0) > 1e-10) {
                normalized_matrix = matrix_values.map(row => 
                    row.map(val => val / total_sum)
                );
            }
            
            // Calculate row and column entropies
            const row_marginals = normalized_matrix.map(row => 
                row.reduce((sum, val) => sum + val, 0)
            );
            
            const column_marginals = [];
            for (let col_index = 0; col_index < num_cols; col_index++) {
                let col_sum = 0;
                for (let row_index = 0; row_index < num_rows; row_index++) {
                    col_sum += normalized_matrix[row_index][col_index];
                }
                column_marginals.push(col_sum);
            }
            
            // Calculate entropies
            let row_entropy = 0;
            for (const prob of row_marginals) {
                if (prob > 0) {
                    row_entropy -= prob * Math.log2(prob);
                }
            }
            
            let col_entropy = 0;
            for (const prob of column_marginals) {
                if (prob > 0) {
                    col_entropy -= prob * Math.log2(prob);
                }
            }
            
            // Normalize MI by geometric mean of entropies
            const entropy_product = row_entropy * col_entropy;
            if (entropy_product === 0) {
                return 0;
            }
            
            return mutual_info / Math.sqrt(entropy_product);
        }

        /**
         * Calculates the information content from each classifier answer
         * @param {Array<Array<number>>} matrix_values - 2D array of matrix values
         * @returns {Array<number>} Information content for each predicted class in bits
         */
        function calculateClassifierAnswerInformation(matrix_values) {
            const num_rows = matrix_values.length;
            const num_cols = matrix_values[0].length;
            
            // Calculate total sum for normalization
            const total_sum = matrix_values.flat().reduce((sum, val) => sum + val, 0);
            if (total_sum === 0) {
                return new Array(num_cols).fill(0);
            }
            
            // Calculate column marginals P(predicted = j)
            const column_marginals = [];
            for (let col_index = 0; col_index < num_cols; col_index++) {
                let col_sum = 0;
                for (let row_index = 0; row_index < num_rows; row_index++) {
                    col_sum += matrix_values[row_index][col_index];
                }
                column_marginals.push(col_sum / total_sum);
            }
            
            // Calculate row marginals P(true = i)
            const row_marginals = [];
            for (let row_index = 0; row_index < num_rows; row_index++) {
                let row_sum = 0;
                for (let col_index = 0; col_index < num_cols; col_index++) {
                    row_sum += matrix_values[row_index][col_index];
                }
                row_marginals.push(row_sum / total_sum);
            }
            
            // For each predicted class j, calculate I(True; Predicted=j)
            const information_per_answer = [];
            for (let col_index = 0; col_index < num_cols; col_index++) {
                let information = 0;
                
                if (column_marginals[col_index] > 0) {
                    // Calculate conditional probabilities P(true=i | predicted=j)
                    for (let row_index = 0; row_index < num_rows; row_index++) {
                        const joint_prob = matrix_values[row_index][col_index] / total_sum;
                        const conditional_prob = joint_prob / column_marginals[col_index];
                        const marginal_prob = row_marginals[row_index];
                        
                        if (conditional_prob > 0 && marginal_prob > 0) {
                            // I(True=i; Predicted=j) = log‚ÇÇ(P(true=i|pred=j) / P(true=i))
                            information += conditional_prob * Math.log2(conditional_prob / marginal_prob);
                        }
                    }
                }
                
                information_per_answer.push(information);
            }
            
            return information_per_answer;
        }

        /**
         * Calculates and displays matrix statistics
         * @param {Object} parsed_data - Parsed table data
         * @param {string} normalization_type - Type of normalization applied
         * @param {boolean} use_smoothing - Whether smoothing was applied
         * @param {number} alpha - Smoothing parameter used
         * side-effects: Modifies DOM element with id 'stats-container'
         */
        function displayMatrixStatistics(parsed_data, normalization_type = 'none', use_smoothing = false, alpha = 0.5, smoothing_type = 'uniform', k_value = 0.5, alpha_prior = 0.5, alpha_prediction = 0.5) {
            const stats_container = document.getElementById('stats-container');
            
            // Use normalized matrix for statistics
            const display_matrix = applyNormalization(parsed_data.matrix_values, normalization_type, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction, parsed_data.row_labels);
            
            // Calculate statistics
            const all_values = display_matrix.flat();
            const min_value = Math.min(...all_values);
            const max_value = Math.max(...all_values);
            const mean_value = all_values.reduce((sum, val) => sum + val, 0) / all_values.length;
            const matrix_dimensions = `${display_matrix.length}√ó${display_matrix[0].length}`;
            
            // Calculate trace and mutual information
            const trace_value = calculateTrace(display_matrix);
            const num_classes = Math.min(display_matrix.length, display_matrix[0].length);
            const normalized_trace = num_classes > 0 ? trace_value / num_classes : 0;
            
            // Calculate minimum diagonal value (worst class accuracy when normalized by truth)
            const diagonal_values = [];
            for (let idx = 0; idx < num_classes; idx++) {
                diagonal_values.push(display_matrix[idx][idx]);
            }
            const min_diagonal = diagonal_values.length > 0 ? Math.min(...diagonal_values) : 0;
            
            const mutual_info = calculateMutualInformation(display_matrix);
            const normalized_mutual_info = calculateNormalizedMutualInformation(display_matrix);
            const answer_information = calculateClassifierAnswerInformation(display_matrix);
            
            // Create stat boxes
            const normalization_labels = (LANGUAGES[currentLanguage]?.strings?.normalizationNames) || {
                'none': 'Original',
                'row': 'By Truth (Rows)',
                'column': 'By Prediction (Columns)', 
                'row_then_column': 'Truth ‚Üí Prediction',
                'sinkhorn_knopp': 'Sinkhorn-Knopp',
                'sum': 'Sum Normalized',
                'prior': 'Prior Normalized',
                'prior_then_column': 'Prior ‚Üí Prediction'
            };
            
            const statistics = [
                { label: t('matrixTitle'), value: normalization_labels[normalization_type], tooltip: '' },
                { label: t('stats.dimensions'), value: matrix_dimensions, tooltip: t('stats.dimensionsTip') },
                { label: t('stats.min'), value: formatNumberForDisplay(min_value, 4), tooltip: t('stats.minTip') },
                { label: t('stats.max'), value: formatNumberForDisplay(max_value, 4), tooltip: t('stats.maxTip') },
                { label: t('stats.mean'), value: formatNumberForDisplay(mean_value, 4), tooltip: t('stats.meanTip') },
                { label: t('stats.trace'), value: formatNumberForDisplay(trace_value, 4), tooltip: t('stats.traceTip') },
                { label: t('stats.tracePerClass'), value: formatNumberForDisplay(normalized_trace, 4), tooltip: t('stats.tracePerClassTip') },
                { label: t('stats.minDiagonal'), value: formatNumberForDisplay(min_diagonal, 4), tooltip: t('stats.minDiagonalTip') },
                { label: t('stats.mi'), value: formatNumberForDisplay(mutual_info, 4), tooltip: t('stats.miTip') },
                { label: t('stats.nmi'), value: formatNumberForDisplay(normalized_mutual_info, 4), tooltip: t('stats.nmiTip') }
            ];
            
            stats_container.innerHTML = '';
            
            for (const stat of statistics) {
                const stat_box = document.createElement('div');
                stat_box.className = 'stat-box';
                
                // Add tooltip if available
                if (stat.tooltip) {
                    stat_box.setAttribute('data-tooltip', stat.tooltip);
                }
                
                const label_element = document.createElement('h3');
                label_element.textContent = stat.label;
                
                const value_element = document.createElement('div');
                value_element.className = 'value';
                value_element.textContent = stat.value;
                
                stat_box.appendChild(label_element);
                stat_box.appendChild(value_element);
                stats_container.appendChild(stat_box);
            }
            
            stats_container.style.display = 'grid';
        }

        /**
         * Displays RAS decomposition for Sinkhorn-Knopp normalization
         * @param {Object} parsed_data - Parsed table data
         * @param {Object} decomposition - RAS decomposition result
         * side-effects: Modifies DOM element with id 'decomposition-container'
         */
        function displayDecomposition(parsed_data, decomposition) {
            const decomposition_container = document.getElementById('decomposition-container');
            
            // Create the display content
            const row_scaling_html = decomposition.row_scaling.map((value, index) => `
                <div class="scaling-item">
                    <span class="label">${parsed_data.row_labels[index]}:</span>
                    <span class="value">${value.toFixed(6)}</span>
                </div>
            `).join('');
            
            const column_scaling_html = decomposition.column_scaling.map((value, index) => `
                <div class="scaling-item">
                    <span class="label">${parsed_data.column_labels[index]}:</span>
                    <span class="value">${value.toFixed(6)}</span>
                </div>
            `).join('');
            
            decomposition_container.innerHTML = `
                <div class="decomposition-title" data-tooltip="${t('tooltips.rasTooltip')}">
                    ${t('tooltips.rasTitle')}
                </div>
                <div class="decomposition-content">
                    <div class="scaling-section">
                        <h4>${t('tooltips.rowScalingFactors')}</h4>
                        <div class="scaling-values">
                            ${row_scaling_html}
                        </div>
                    </div>
                    <div class="scaling-section">
                        <h4>${t('tooltips.columnScalingFactors')}</h4>
                        <div class="scaling-values">
                            ${column_scaling_html}
                        </div>
                    </div>
                    <div class="reconstruction-formula" data-tooltip="${t('tooltips.reconstructionTooltip')}">
                        ${t('tooltips.reconstructionFormula')}
                    </div>
                </div>
            `;
            
            decomposition_container.style.display = 'block';
        }

        /**
         * Hides the decomposition display
         * side-effects: Modifies DOM element with id 'decomposition-container'
         */
        function hideDecomposition() {
            const decomposition_container = document.getElementById('decomposition-container');
            decomposition_container.style.display = 'none';
            decomposition_container.innerHTML = '';
        }

        /**
         * Displays error message to user
         * @param {string} error_text - Error message to display
         * side-effects: Modifies DOM elements for error display
         */
        function showErrorMessage(error_text) {
            const error_element = document.getElementById('error-message');
            error_element.textContent = error_text;
            error_element.style.display = 'block';
            
            // Hide matrix, text view, decomposition, and stats
            document.getElementById('matrix-container').innerHTML = '';
            document.getElementById('text-view-container').innerHTML = '';
            document.getElementById('text-view-container').style.display = 'none';
            document.getElementById('decomposition-container').style.display = 'none';
            document.getElementById('stats-container').style.display = 'none';
        }

        /**
         * Hides error message
         * side-effects: Modifies DOM element with id 'error-message'
         */
        function hideErrorMessage() {
            const error_element = document.getElementById('error-message');
            error_element.style.display = 'none';
        }

        /**
         * Updates the matrix title based on normalization type
         * @param {string} normalization_type - Type of normalization applied
         * side-effects: Modifies DOM element with id 'matrix-title'
         */
        function updateMatrixTitle(normalization_type) {
            const title_element = document.getElementById('matrix-title');
            const normName = LANGUAGES?.[currentLanguage]?.strings?.normalizationNames?.[normalization_type];
            if (!normName) {
                console.error(`i18n: missing normalization name for '${normalization_type}'`);
                title_element.textContent = `${t('matrixTitle')} (${normalization_type})`;
                return;
            }
            title_element.textContent = `${t('matrixTitle')} (${normName})`;
        }

        /**
         * Main function to process table input and generate matrix visualization
         * side-effects: Updates DOM with matrix visualization or error message
         */
        function processTableInput() {
            const input_element = document.getElementById('table-input');
            const table_data = input_element.value.trim();
            
            if (!table_data) {
                showErrorMessage('Please enter table data');
                return;
            }
            
            try {
                hideErrorMessage();
                const parsed_data = parseTableData(table_data);
                
                // Show normalization options and matrix controls after successful parsing
                document.getElementById('normalization-section').style.display = 'block';
                document.getElementById('matrix-controls').style.display = 'flex';
                
                // Update prior frequencies input to match new labels
                const prior_frequencies_input = document.getElementById('prior-frequencies-input');
                const existing_priors_text = prior_frequencies_input.value.trim();
                let existing_priors = {};
                
                // Try to parse existing prior frequencies
                if (existing_priors_text) {
                    try {
                        existing_priors = JSON.parse(existing_priors_text);
                    } catch (e) {
                        // If parsing fails, start with empty object
                        existing_priors = {};
                    }
                }
                
                // Create updated priors object with new labels
                const updated_priors = {};
                parsed_data.row_labels.forEach(label => {
                    // Preserve existing value if label exists, otherwise use default of 1
                    updated_priors[label] = existing_priors.hasOwnProperty(label) ? existing_priors[label] : 1;
                });
                
                // Update the input field
                prior_frequencies_input.value = JSON.stringify(updated_priors, null, 2);
                clearPriorFrequenciesError();
                
                // Show prior frequencies section (always visible)
                const prior_section = document.getElementById('prior-frequencies-section');
                prior_section.style.display = 'block';
                
                // Re-initialize tooltips for newly shown controls
                initializeTooltips();
                
                // Get selected normalization type and options
                const selected_normalization = document.querySelector('input[name="normalization"]:checked').value;
                const include_sums = document.getElementById('include-sums').checked;
                const include_info = document.getElementById('include-info').checked;
                const use_smoothing = document.getElementById('use-smoothing').checked;
                const alpha = parseFloat(document.getElementById('alpha-value').value);
                const smoothing_type = document.getElementById('smoothing-type').value;
                const k_value = parseFloat(document.getElementById('k-value').value);
                const alpha_prior = parseFloat(document.getElementById('alpha-prior').value);
                const alpha_prediction = parseFloat(document.getElementById('alpha-prediction').value);
                
                updateMatrixTitle(selected_normalization);
                renderConfusionMatrix(parsed_data, selected_normalization, include_sums, include_info, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction);
                renderTextView(parsed_data, selected_normalization, include_sums, include_info, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction);
                displayMatrixStatistics(parsed_data, selected_normalization, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction);
                // Ensure tooltips/info buttons applied to newly rendered elements
                initializeTooltips();
                
                // Show decomposition only for Sinkhorn-Knopp normalization
                if (selected_normalization === 'sinkhorn_knopp') {
                    const decomposition = normalizeSinkhornKnopp(parsed_data.matrix_values, 100, 1e-6, true);
                    displayDecomposition(parsed_data, decomposition);
                } else {
                    hideDecomposition();
                }
            } catch (error) {
                showErrorMessage(`Error: ${error.message}`);
                // Hide normalization options and matrix controls on error
                document.getElementById('normalization-section').style.display = 'none';
                document.getElementById('matrix-controls').style.display = 'none';
            }
        }

        /**
         * Updates the matrix display when normalization type changes
         * side-effects: Re-renders matrix with new normalization
         */
        function updateMatrixNormalization() {
            const input_element = document.getElementById('table-input');
            const table_data = input_element.value.trim();
            
            if (!table_data) {
                return;
            }
            
            try {
                const parsed_data = parseTableData(table_data);
                const selected_normalization = document.querySelector('input[name="normalization"]:checked').value;
                const include_sums = document.getElementById('include-sums').checked;
                const include_info = document.getElementById('include-info').checked;
                const use_smoothing = document.getElementById('use-smoothing').checked;
                const alpha = parseFloat(document.getElementById('alpha-value').value);
                const smoothing_type = document.getElementById('smoothing-type').value;
                const k_value = parseFloat(document.getElementById('k-value').value);
                const alpha_prior = parseFloat(document.getElementById('alpha-prior').value);
                const alpha_prediction = parseFloat(document.getElementById('alpha-prediction').value);
                
                updateMatrixTitle(selected_normalization);
                renderConfusionMatrix(parsed_data, selected_normalization, include_sums, include_info, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction);
                renderTextView(parsed_data, selected_normalization, include_sums, include_info, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction);
                displayMatrixStatistics(parsed_data, selected_normalization, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction);
                // Re-apply tooltips/info buttons for updated DOM
                initializeTooltips();
                
                // Show decomposition only for Sinkhorn-Knopp normalization
                if (selected_normalization === 'sinkhorn_knopp') {
                    const decomposition = normalizeSinkhornKnopp(parsed_data.matrix_values, 100, 1e-6, true);
                    displayDecomposition(parsed_data, decomposition);
                } else {
                    hideDecomposition();
                }
            } catch (error) {
                // Error handling is already done in processTableInput
                console.error('Error updating normalization:', error);
            }
        }

        /**
         * Gets all saved template names from localStorage
         * @returns {Array<string>} Array of template names
         */
        function getSavedTemplateNames() {
            const saved_templates = [];
            for (let idx = 0; idx < localStorage.length; idx++) {
                const key = localStorage.key(idx);
                if (key && key.startsWith('confusion_matrix_template_')) {
                    const template_name = key.replace('confusion_matrix_template_', '');
                    saved_templates.push(template_name);
                }
            }
            return saved_templates.sort();
        }

        /**
         * Saves template data and prior frequencies to localStorage
         * @param {string} template_name - Name of the template
         * @param {string} template_data - Matrix data to save
         * @param {string} prior_frequencies - Prior frequencies JSON string
         * side-effects: Stores data in localStorage
         */
        function saveTemplateToLocalStorage(template_name, template_data, prior_frequencies) {
            assert(typeof template_name === 'string' && template_name.trim().length > 0, 
                   `Template name must be non-empty string, got: ${template_name}`);
            assert(typeof template_data === 'string', 
                   `Template data must be string, got: ${typeof template_data}`);
            
            const storage_key = 'confusion_matrix_template_' + template_name.trim();
            const template_object = {
                matrix_data: template_data,
                prior_frequencies: prior_frequencies || ''
            };
            localStorage.setItem(storage_key, JSON.stringify(template_object));
        }

        /**
         * Loads template data and prior frequencies from localStorage
         * @param {string} template_name - Name of the template
         * @returns {Object|null} Object with matrix_data and prior_frequencies, or null if not found
         */
        function loadTemplateFromLocalStorage(template_name) {
            assert(typeof template_name === 'string' && template_name.trim().length > 0, 
                   `Template name must be non-empty string, got: ${template_name}`);
            
            const storage_key = 'confusion_matrix_template_' + template_name.trim();
            const stored_data = localStorage.getItem(storage_key);
            
            if (!stored_data) {
                return null;
            }
            
            // Try to parse as JSON (new format with prior frequencies)
            try {
                const template_object = JSON.parse(stored_data);
                if (template_object.matrix_data) {
                    return template_object;
                }
            } catch (e) {
                // Fallback: old format (just string data)
                return {
                    matrix_data: stored_data,
                    prior_frequencies: ''
                };
            }
            
            return null;
        }

        /**
         * Checks if a template exists in localStorage
         * @param {string} template_name - Name of the template
         * @returns {boolean} True if template exists, false otherwise
         */
        function templateExistsInLocalStorage(template_name) {
            if (!template_name || !template_name.trim()) {
                return false;
            }
            const storage_key = 'confusion_matrix_template_' + template_name.trim();
            return localStorage.getItem(storage_key) !== null;
        }

        /**
         * Deletes a template from localStorage
         * @param {string} template_name - Name of the template to delete
         * side-effects: Removes template from localStorage
         */
        function deleteTemplateFromLocalStorage(template_name) {
            assert(typeof template_name === 'string' && template_name.trim().length > 0, 
                   `Template name must be non-empty string, got: ${template_name}`);
            
            const storage_key = 'confusion_matrix_template_' + template_name.trim();
            localStorage.removeItem(storage_key);
        }

        /**
         * Updates the visibility of the delete button based on whether the title matches an existing template
         * side-effects: Shows/hides delete button
         */
        function updateDeleteButtonVisibility() {
            const title_input = document.getElementById('template-title-input');
            const delete_btn = document.getElementById('delete-template-btn');
            const template_name = title_input.value.trim();
            
            if (template_name && templateExistsInLocalStorage(template_name)) {
                delete_btn.style.display = 'block';
            } else {
                delete_btn.style.display = 'none';
            }
        }

        /**
         * Serializes current state to URL parameters
         * @returns {string} URL with encoded state parameters
         */
        function serializeStateToURL() {
            const params = new URLSearchParams();
            
            // Matrix data (base64 encoded to handle special characters)
            const matrix_data = document.getElementById('table-input').value.trim();
            if (matrix_data) {
                params.set('data', btoa(unescape(encodeURIComponent(matrix_data))));
            }
            
            // Prior frequencies (base64 encoded)
            const prior_frequencies = document.getElementById('prior-frequencies-input').value.trim();
            if (prior_frequencies) {
                params.set('priors', btoa(unescape(encodeURIComponent(prior_frequencies))));
            }
            
            // Normalization type
            const normalization_radio = document.querySelector('input[name="normalization"]:checked');
            if (normalization_radio) {
                params.set('norm', normalization_radio.value);
            }
            
            // Smoothing settings
            const use_smoothing = document.getElementById('use-smoothing').checked;
            params.set('smooth', use_smoothing ? '1' : '0');
            
            if (use_smoothing) {
                const smoothing_type = document.getElementById('smoothing-type').value;
                params.set('smooth_type', smoothing_type);
                
                if (smoothing_type === 'uniform') {
                    const alpha = document.getElementById('alpha-value').value;
                    params.set('alpha', alpha);
                } else if (smoothing_type === 'hierarchical') {
                    const k = document.getElementById('k-value').value;
                    const alpha_prior = document.getElementById('alpha-prior').value;
                    const alpha_prediction = document.getElementById('alpha-prediction').value;
                    params.set('k', k);
                    params.set('alpha_prior', alpha_prior);
                    params.set('alpha_pred', alpha_prediction);
                }
            }
            
            // View settings
            const include_sums = document.getElementById('include-sums').checked;
            const include_info = document.getElementById('include-info').checked;
            params.set('sums', include_sums ? '1' : '0');
            params.set('info', include_info ? '1' : '0');
            
            // View mode (table or text)
            const table_view_btn = document.getElementById('table-view-btn');
            const view_mode = table_view_btn && table_view_btn.classList.contains('active') ? 'table' : 'text';
            params.set('view', view_mode);
            
            // Title (URL encoded)
            const title = document.getElementById('template-title-input').value.trim();
            if (title) {
                params.set('title', encodeURIComponent(title));
            }
            
            // Build URL
            const base_url = window.location.origin + window.location.pathname;
            return base_url + '?' + params.toString();
        }

        /**
         * Parses URL parameters and restores state
         * @returns {boolean} True if state was restored, false otherwise
         */
        function parseStateFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Check if we have any state parameters
            if (!params.has('data') && !params.has('norm')) {
                return false;
            }
            
            try {
                // Restore matrix data first
                if (params.has('data')) {
                    const encoded_data = params.get('data');
                    const matrix_data = decodeURIComponent(escape(atob(encoded_data)));
                    document.getElementById('table-input').value = matrix_data;
                }
                
                // Restore prior frequencies
                if (params.has('priors')) {
                    const encoded_priors = params.get('priors');
                    const prior_frequencies = decodeURIComponent(escape(atob(encoded_priors)));
                    document.getElementById('prior-frequencies-input').value = prior_frequencies;
                }
                
                // Restore title
                if (params.has('title')) {
                    const title = decodeURIComponent(params.get('title'));
                    document.getElementById('template-title-input').value = title;
                    // Update delete button visibility based on restored title
                    updateDeleteButtonVisibility();
                }
                
                // Restore normalization (before smoothing, as smoothing change events might trigger updates)
                if (params.has('norm')) {
                    const norm_value = params.get('norm');
                    const norm_radio = document.querySelector(`input[name="normalization"][value="${norm_value}"]`);
                    if (norm_radio) {
                        norm_radio.checked = true;
                    }
                }
                
                // Restore view settings (before processing, as they affect rendering)
                if (params.has('sums')) {
                    document.getElementById('include-sums').checked = params.get('sums') === '1';
                }
                if (params.has('info')) {
                    document.getElementById('include-info').checked = params.get('info') === '1';
                }
                
                // Restore smoothing settings (set values without triggering updates yet)
                if (params.has('smooth')) {
                    const use_smoothing = params.get('smooth') === '1';
                    const smoothing_checkbox = document.getElementById('use-smoothing');
                    smoothing_checkbox.checked = use_smoothing;
                    
                    // Manually show/hide smoothing options without triggering change event
                    const smoothing_options = document.getElementById('smoothing-options');
                    if (smoothing_options) {
                        smoothing_options.style.display = use_smoothing ? 'flex' : 'none';
                    }
                    
                    if (use_smoothing && params.has('smooth_type')) {
                        const smoothing_type = params.get('smooth_type');
                        const smoothing_type_select = document.getElementById('smoothing-type');
                        if (smoothing_type_select) {
                            smoothing_type_select.value = smoothing_type;
                            
                            // Manually show/hide appropriate input groups
                            const alpha_group = document.getElementById('alpha-input-group');
                            const hierarchical_params = document.getElementById('hierarchical-params');
                            
                            if (smoothing_type === 'uniform') {
                                if (alpha_group) alpha_group.style.display = 'flex';
                                if (hierarchical_params) hierarchical_params.style.display = 'none';
                            } else if (smoothing_type === 'hierarchical') {
                                if (alpha_group) alpha_group.style.display = 'none';
                                if (hierarchical_params) hierarchical_params.style.display = 'flex';
                            }
                            
                            // Set parameter values
                            if (smoothing_type === 'uniform' && params.has('alpha')) {
                                document.getElementById('alpha-value').value = params.get('alpha');
                            } else if (smoothing_type === 'hierarchical') {
                                if (params.has('k')) {
                                    document.getElementById('k-value').value = params.get('k');
                                }
                                if (params.has('alpha_prior')) {
                                    document.getElementById('alpha-prior').value = params.get('alpha_prior');
                                }
                                if (params.has('alpha_pred')) {
                                    document.getElementById('alpha-prediction').value = params.get('alpha_pred');
                                }
                            }
                        }
                    }
                }
                
                // Restore view mode
                if (params.has('view')) {
                    const view_mode = params.get('view');
                    const table_view_btn = document.getElementById('table-view-btn');
                    const text_view_btn = document.getElementById('text-view-btn');
                    const matrix_container = document.getElementById('matrix-container');
                    const text_view_container = document.getElementById('text-view-container');
                    
                    if (view_mode === 'table' && table_view_btn) {
                        table_view_btn.classList.add('active');
                        if (text_view_btn) text_view_btn.classList.remove('active');
                        if (matrix_container) matrix_container.style.display = 'block';
                        if (text_view_container) text_view_container.style.display = 'none';
                    } else if (view_mode === 'text' && text_view_btn) {
                        text_view_btn.classList.add('active');
                        if (table_view_btn) table_view_btn.classList.remove('active');
                        if (matrix_container) matrix_container.style.display = 'none';
                        if (text_view_container) text_view_container.style.display = 'block';
                    }
                }
                
                // Process the input to render the matrix (this will use all the restored values)
                if (params.has('data')) {
                    processTableInput();
                }
                
                return true;
            } catch (error) {
                console.error('Error parsing state from URL:', error);
                return false;
            }
        }

        /**
         * Populates template selector with saved templates
         * side-effects: Modifies template selector DOM
         */
        function populateTemplateSelector() {
            const template_select = document.getElementById('template-select');
            if (!template_select) return;
            
            // Remove existing saved template options (keep built-in ones)
            const existing_options = Array.from(template_select.querySelectorAll('option'));
            existing_options.forEach(option => {
                if (option.value.startsWith('saved_')) {
                    option.remove();
                }
            });
            
            // Add saved templates
            const saved_names = getSavedTemplateNames();
            saved_names.forEach(template_name => {
                const option = document.createElement('option');
                option.value = 'saved_' + template_name;
                option.textContent = template_name;
                template_select.appendChild(option);
            });
        }

        // Event listeners
        document.getElementById('parse-button').addEventListener('click', processTableInput);
        
        // Template selector event listener
        document.getElementById('template-select').addEventListener('change', function() {
            const template_key = this.value;
            
            // Handle saved templates
            if (template_key.startsWith('saved_')) {
                const template_name = template_key.replace('saved_', '');
                const template_object = loadTemplateFromLocalStorage(template_name);
                if (template_object) {
                    document.getElementById('table-input').value = template_object.matrix_data;
                    document.getElementById('template-title-input').value = template_name;
                    // Restore prior frequencies if saved
                    if (template_object.prior_frequencies) {
                        document.getElementById('prior-frequencies-input').value = template_object.prior_frequencies;
                    } else {
                        // Clear prior frequencies if not saved
                        document.getElementById('prior-frequencies-input').value = '';
                    }
                    clearPriorFrequenciesError();
                    updateDeleteButtonVisibility();
                    processTableInput();
                } else {
                    alert('Template not found in local storage');
                    populateTemplateSelector();
                }
                return;
            }
            
            // Handle built-in templates
            const template_map = {
                'multiclass': 'multiclass',
                'all_positive': 'allPositive',
                'one_percent_positive': 'onePercentPositive'
            };
            const translation_key = template_map[template_key];
            const template_data = t('templateData.' + translation_key) || t('exampleData');
            document.getElementById('table-input').value = template_data;
            document.getElementById('template-title-input').value = '';
            // Clear prior frequencies for built-in templates (will be initialized with defaults when data is parsed)
            document.getElementById('prior-frequencies-input').value = '';
            clearPriorFrequenciesError();
            updateDeleteButtonVisibility();
            processTableInput();
        });

        // Save template button event listener
        document.getElementById('save-template-btn').addEventListener('click', function() {
            const title_input = document.getElementById('template-title-input');
            const table_input = document.getElementById('table-input');
            const prior_frequencies_input = document.getElementById('prior-frequencies-input');
            const template_name = title_input.value.trim();
            const template_data = table_input.value.trim();
            const prior_frequencies = prior_frequencies_input.value.trim();
            
            if (!template_name) {
                alert('Please enter a template title');
                title_input.focus();
                return;
            }
            
            if (!template_data) {
                alert('Please enter matrix data to save');
                table_input.focus();
                return;
            }
            
            try {
                // Validate that the data can be parsed
                parseTableData(template_data);
                
                // Validate prior frequencies if provided
                if (prior_frequencies) {
                    try {
                        JSON.parse(prior_frequencies);
                    } catch (e) {
                        alert(`Invalid prior frequencies JSON: ${e.message}`);
                        prior_frequencies_input.focus();
                        return;
                    }
                }
                
                // Save to localStorage (including prior frequencies)
                saveTemplateToLocalStorage(template_name, template_data, prior_frequencies);
                
                // Update template selector
                populateTemplateSelector();
                
                // Select the newly saved template
                const template_select = document.getElementById('template-select');
                template_select.value = 'saved_' + template_name;
                
                alert(`Template "${template_name}" saved successfully!`);
            } catch (error) {
                alert(`Error saving template: ${error.message}`);
            }
            
            // Update delete button visibility after saving
            updateDeleteButtonVisibility();
        });

        // Title input event listener to show/hide delete button
        document.getElementById('template-title-input').addEventListener('input', updateDeleteButtonVisibility);
        document.getElementById('template-title-input').addEventListener('change', updateDeleteButtonVisibility);

        // Delete template button event listener
        document.getElementById('delete-template-btn').addEventListener('click', function() {
            const title_input = document.getElementById('template-title-input');
            const template_name = title_input.value.trim();
            
            if (!template_name) {
                alert('Please enter a template title');
                title_input.focus();
                return;
            }
            
            if (!templateExistsInLocalStorage(template_name)) {
                alert(`Template "${template_name}" not found in local storage`);
                updateDeleteButtonVisibility();
                return;
            }
            
            // Confirm deletion
            if (!confirm(`Are you sure you want to delete template "${template_name}"?`)) {
                return;
            }
            
            try {
                // Delete from localStorage
                deleteTemplateFromLocalStorage(template_name);
                
                // Update template selector
                populateTemplateSelector();
                
                // Clear title input and hide delete button
                title_input.value = '';
                updateDeleteButtonVisibility();
                
                alert(`Template "${template_name}" deleted successfully!`);
            } catch (error) {
                alert(`Error deleting template: ${error.message}`);
            }
        });
        
        document.getElementById('table-input').addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 'Enter') {
                processTableInput();
            }
        });
        
        // Add event listener for alpha value input
        document.getElementById('alpha-value').addEventListener('input', function() {
            // Update matrix when alpha value changes
            updateMatrixNormalization();
        });
        
        // Add event listener for smoothing type selector
        document.getElementById('smoothing-type').addEventListener('change', function() {
            const smoothing_type = this.value;
            const alpha_group = document.getElementById('alpha-input-group');
            const hierarchical_params = document.getElementById('hierarchical-params');
            
            if (smoothing_type === 'hierarchical') {
                alpha_group.style.display = 'none';
                hierarchical_params.style.display = 'flex';
            } else {
                alpha_group.style.display = 'flex';
                hierarchical_params.style.display = 'none';
            }
            updateMatrixNormalization();
        });
        
        // Add event listener for k value input
        document.getElementById('k-value').addEventListener('input', function() {
            updateMatrixNormalization();
        });
        
        // Add event listener for alpha_prior input
        document.getElementById('alpha-prior').addEventListener('input', function() {
            updateMatrixNormalization();
        });
        
        // Add event listener for alpha_prediction input
        document.getElementById('alpha-prediction').addEventListener('input', function() {
            updateMatrixNormalization();
        });
        
        // Add event listeners for normalization radio buttons
        document.addEventListener('change', function(event) {
            if (event.target.name === 'normalization') {
                // Clear prior frequencies error when switching normalization (but keep section visible)
                if (event.target.value !== 'prior' && event.target.value !== 'prior_then_column') {
                    clearPriorFrequenciesError();
                }
                updateMatrixNormalization();
            }
            if (event.target.id === 'include-sums') {
                updateMatrixNormalization();
            }
            if (event.target.id === 'include-info') {
                updateMatrixNormalization();
            }
            if (event.target.id === 'use-smoothing') {
                // Show/hide smoothing options based on smoothing toggle
                const smoothing_options = document.getElementById('smoothing-options');
                smoothing_options.style.display = event.target.checked ? 'flex' : 'none';
                updateMatrixNormalization();
            }
        });
        
        /**
         * Shows validation error for prior frequencies input
         * @param {string} error_message - Error message to display
         */
        function showPriorFrequenciesError(error_message) {
            const input = document.getElementById('prior-frequencies-input');
            const error_div = document.getElementById('prior-frequencies-error');
            input.classList.add('error');
            error_div.textContent = error_message;
            error_div.classList.add('show');
        }

        /**
         * Clears validation error for prior frequencies input
         */
        function clearPriorFrequenciesError() {
            const input = document.getElementById('prior-frequencies-input');
            const error_div = document.getElementById('prior-frequencies-error');
            input.classList.remove('error');
            error_div.classList.remove('show');
            error_div.textContent = '';
        }

        // Prior frequencies spoiler toggle
        document.getElementById('prior-frequencies-header').addEventListener('click', function() {
            const section = document.getElementById('prior-frequencies-section');
            section.classList.toggle('expanded');
        });

        // Prior frequencies input change listener
        document.getElementById('prior-frequencies-input').addEventListener('input', function() {
            const selected_normalization = document.querySelector('input[name="normalization"]:checked');
            if (selected_normalization && (selected_normalization.value === 'prior' || selected_normalization.value === 'prior_then_column')) {
                // Clear any previous errors
                clearPriorFrequenciesError();
                updateMatrixNormalization();
            }
        });

        /**
         * Parses and normalizes prior frequencies from JSON input
         * @param {string} json_input - JSON string mapping class names to frequencies
         * @param {Array<string>} class_names - Array of class names (row labels)
         * @returns {Array<number>} Normalized prior frequencies (sums to 1.0)
         */
        function parsePriorFrequencies(json_input, class_names) {
            if (!json_input || !json_input.trim()) {
                // Default: all frequencies are 1
                return new Array(class_names.length).fill(1.0 / class_names.length);
            }
            
            try {
                const priors_obj = JSON.parse(json_input);
                const priors = class_names.map(class_name => {
                    const freq = priors_obj[class_name];
                    if (freq === undefined || freq === null) {
                        return 1.0; // Default to 1 if not specified
                    }
                    const num_freq = typeof freq === 'number' ? freq : parseFloat(freq);
                    if (isNaN(num_freq) || num_freq < 0) {
                        throw new Error(`Invalid prior frequency for class "${class_name}": ${freq}`);
                    }
                    return num_freq;
                });
                
                // Normalize to sum to 1.0
                const sum = priors.reduce((s, p) => s + p, 0);
                if (sum === 0) {
                    throw new Error('All prior frequencies are zero');
                }
                return priors.map(p => p / sum);
            } catch (error) {
                throw new Error(`Failed to parse prior frequencies: ${error.message}`);
            }
        }

        // Add event listeners for view mode buttons
        document.getElementById('table-view-btn').addEventListener('click', function() {
            document.getElementById('matrix-container').style.display = 'block';
            document.getElementById('text-view-container').style.display = 'none';
            
            document.getElementById('table-view-btn').classList.add('active');
            document.getElementById('text-view-btn').classList.remove('active');
        });
        
        document.getElementById('text-view-btn').addEventListener('click', function() {
            document.getElementById('matrix-container').style.display = 'none';
            document.getElementById('text-view-container').style.display = 'block';
            
            document.getElementById('text-view-btn').classList.add('active');
            document.getElementById('table-view-btn').classList.remove('active');
        });
        
        // Add event listener for CSV download
        document.getElementById('download-csv-btn').addEventListener('click', function() {
            const input_element = document.getElementById('table-input');
            const table_data = input_element.value.trim();
            
            if (!table_data) {
                alert('Please enter table data first');
                return;
            }
            
            try {
                const parsed_data = parseTableData(table_data);
                const selected_normalization = document.querySelector('input[name="normalization"]:checked').value;
                const include_sums = document.getElementById('include-sums').checked;
                const include_info = document.getElementById('include-info').checked;
                const use_smoothing = document.getElementById('use-smoothing').checked;
                const alpha = parseFloat(document.getElementById('alpha-value').value);
                const smoothing_type = document.getElementById('smoothing-type').value;
                const k_value = parseFloat(document.getElementById('k-value').value);
                const alpha_prior = parseFloat(document.getElementById('alpha-prior').value);
                const alpha_prediction = parseFloat(document.getElementById('alpha-prediction').value);
                
                downloadAsCSV(parsed_data, selected_normalization, include_sums, include_info, use_smoothing, alpha, smoothing_type, k_value, alpha_prior, alpha_prediction);
            } catch (error) {
                alert(`Error generating CSV: ${error.message}`);
            }
        });

        // Share link button event listener
        document.getElementById('share-link-btn').addEventListener('click', function() {
            const input_element = document.getElementById('table-input');
            const table_data = input_element.value.trim();
            
            if (!table_data) {
                alert('Please enter table data first');
                return;
            }
            
            try {
                // Validate that the data can be parsed
                parseTableData(table_data);
                
                // Generate shareable URL
                const share_url = serializeStateToURL();
                
                // Show modal with the link
                const modal = document.getElementById('share-link-modal');
                const link_input = document.getElementById('share-link-input');
                const copied_msg = document.getElementById('share-link-copied');
                
                link_input.value = share_url;
                copied_msg.style.display = 'none';
                modal.style.display = 'block';
            } catch (error) {
                alert(`Error generating share link: ${error.message}`);
            }
        });

        // Copy link button event listener
        document.getElementById('copy-link-btn').addEventListener('click', function() {
            const link_input = document.getElementById('share-link-input');
            link_input.select();
            link_input.setSelectionRange(0, 99999); // For mobile devices
            
            try {
                document.execCommand('copy');
                const copied_msg = document.getElementById('share-link-copied');
                copied_msg.style.display = 'block';
                
                // Hide message after 3 seconds
                setTimeout(function() {
                    copied_msg.style.display = 'none';
                }, 3000);
            } catch (err) {
                // Fallback: try modern clipboard API
                navigator.clipboard.writeText(link_input.value).then(function() {
                    const copied_msg = document.getElementById('share-link-copied');
                    copied_msg.style.display = 'block';
                    setTimeout(function() {
                        copied_msg.style.display = 'none';
                    }, 3000);
                }).catch(function(err) {
                    alert('Failed to copy link. Please copy manually.');
                });
            }
        });

        // Modal close button event listener
        document.querySelector('.modal-close').addEventListener('click', function() {
            document.getElementById('share-link-modal').style.display = 'none';
        });

        // Close modal when clicking outside of it
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('share-link-modal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        });

        // Load example data on page load
        // Make test function available globally for debugging
        window.runParserTests = runParserTests;

        /**
         * Initialize custom tooltips for elements with data-tooltip attribute
         */
        function initializeTooltips() {
            // Remove any existing tooltips
            const existing_tooltips = document.querySelectorAll('.custom-tooltip');
            existing_tooltips.forEach(tooltip => tooltip.remove());
            
            // Find all elements with data-tooltip
            const tooltip_elements = document.querySelectorAll('[data-tooltip]:not(.stat-box)');
            const isMobile = matchMedia('(hover: none), (pointer: coarse)').matches;
            
            tooltip_elements.forEach(element => {
                // Clean previous handlers/info buttons
                element.removeEventListener?.('mouseenter', element._ttEnter || (() => {}));
                element.removeEventListener?.('mouseleave', element._ttLeave || (() => {}));
                const oldBtn = element.querySelector('.info-btn');
                if (oldBtn) oldBtn.remove();

                if (!isMobile) {
                    const enter = function() {
                        const tooltip = document.createElement('div');
                        tooltip.className = 'custom-tooltip';
                        tooltip.textContent = this.getAttribute('data-tooltip');
                        Object.assign(tooltip.style, {
                            position: 'fixed',
                            background: '#333',
                            color: 'white',
                            padding: '16px 20px',
                            borderRadius: '8px',
                            fontSize: '14px',
                            lineHeight: '1.5',
                            whiteSpace: 'pre-line',
                            zIndex: '9999',
                            opacity: '0.95',
                            maxWidth: '400px',
                            textAlign: 'left',
                            boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
                            pointerEvents: 'none',
                            fontFamily: 'system-ui, -apple-system, sans-serif'
                        });
                        const rect = this.getBoundingClientRect();
                        tooltip.style.left = (rect.left + rect.width / 2) + 'px';
                        tooltip.style.top = (rect.top - 10) + 'px';
                        tooltip.style.transform = 'translateX(-50%) translateY(-100%)';
                        document.body.appendChild(tooltip);
                    };
                    const leave = function() {
                        const tooltips = document.querySelectorAll('.custom-tooltip');
                        tooltips.forEach(tooltip => tooltip.remove());
                    };
                    element._ttEnter = enter;
                    element._ttLeave = leave;
                    element.addEventListener('mouseenter', enter);
                    element.addEventListener('mouseleave', leave);
                } else {
                    const infoBtn = document.createElement('span');
                    infoBtn.className = 'info-btn';
                    infoBtn.textContent = 'i';
                    infoBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const modal = document.createElement('div');
                        modal.className = 'mobile-info-modal';
                        const content = document.createElement('div');
                        content.className = 'modal-content';
                        const header = document.createElement('div');
                        header.className = 'modal-header';
                        const title = document.createElement('h3');
                        title.className = 'modal-title';
                        title.textContent = element.textContent?.trim() || 'Info';
                        const closeBtn = document.createElement('button');
                        closeBtn.className = 'close-btn';
                        closeBtn.textContent = '√ó';
                        closeBtn.addEventListener('click', function() { modal.remove(); });
                        header.appendChild(title);
                        header.appendChild(closeBtn);
                        const body = document.createElement('div');
                        body.style.whiteSpace = 'pre-wrap';
                        body.style.fontSize = '14px';
                        body.style.lineHeight = '1.6';
                        body.textContent = element.getAttribute('data-tooltip') || '';
                        content.appendChild(header);
                        content.appendChild(body);
                        modal.appendChild(content);
                        modal.addEventListener('click', function(ev) { if (ev.target === modal) modal.remove(); });
                        document.body.appendChild(modal);
                    });
                    element.appendChild(infoBtn);
                }
            });
        }

        window.addEventListener('load', function() {
            const run_tests = false;
            
            if (run_tests) {
                // Run tests in console for debugging
                console.log('Running parser tests...');
                runParserTests();
            }
            
            // Load translations and init i18n
            loadTranslations().then(() => {
                const select = document.getElementById('language-select');
                if (select && select.value) currentLanguage = select.value;
                updateUILanguage();
                initializeTooltips();
                populateTemplateSelector();
                
                // Try to parse state from URL on page load (after translations are loaded)
                // If URL contains state parameters, restore them; otherwise, do nothing
                parseStateFromURL();
            }).catch((e) => {
                console.error('i18n: failed to load translations', e);
                // Even if translations fail, try to parse URL state
                parseStateFromURL();
            });
            
            // Populate template selector with saved templates on page load
            populateTemplateSelector();

            // Language selector
            const languageSelect = document.getElementById('language-select');
            if (languageSelect) {
                languageSelect.addEventListener('change', function() {
                    currentLanguage = this.value;
                    updateUILanguage();
                    const selected_normalization = document.querySelector('input[name="normalization"]:checked');
                    if (!selected_normalization) {
                        console.error('i18n: normalization radio not found');
                        return;
                    }
                    updateMatrixTitle(selected_normalization.value);
                    // Re-render matrix/text/stats so dynamic row headers (e.g., Answer Info) are translated immediately
                    try {
                        updateMatrixNormalization();
                    } catch (e) {
                        console.error('i18n: failed to re-render after language change', e);
                    }
                });
            } else {
                console.error('i18n: language selector not found');
            }
            
            const example_data = t('exampleData');
            
            document.getElementById('table-input').value = example_data;
            processTableInput();
        });
    </script>
<p><a href="https://rashchedrin.github.io/">My other pages</a></p>
</body>
</html>
